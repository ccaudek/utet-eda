{
  "hash": "cf3eebdbea0ecf96dbec714fb412d964",
  "result": {
    "engine": "knitr",
    "markdown": "# Usare `dplyr` {#sec-dplyr}\n\n## Introduzione {.unnumbered .unlisted}\n\nL'obiettivo di questo capitolo è fornire un'introduzione alle funzioni principali del pacchetto `dplyr` per le operazioni di *data wrangling*, cioè per il preprocessing e la pulizia dei dati. In R, queste operazioni sono strettamente legate al concetto di \"data tidying\", che si riferisce all'organizzazione sistematica dei dati per facilitare l'analisi.[^1]\n\n[^1]: Per comprendere meglio il concetto di \"data tidying\", possiamo rifarci a una citazione tratta dal testo di riferimento [*R for Data Science (2e)*](https://r4ds.hadley.nz): \"Tidy datasets are all alike, but every messy dataset is messy in its own way.\" \n\nL'essenza del \"data tidying\" è organizzare i dati in un formato che sia facile da gestire e analizzare. Anche se gli stessi dati possono essere rappresentati in vari modi, non tutte le rappresentazioni sono ugualmente efficienti o facili da usare. Un dataset \"tidy\" segue tre principi fondamentali che lo rendono particolarmente pratico:\n\n1. **Ogni variabile è una colonna**: ogni colonna nel dataset rappresenta una singola variabile.\n2. **Ogni osservazione è una riga**: ogni riga nel dataset rappresenta un'unica osservazione.\n3. **Ogni valore è una cella**: ogni cella del dataset contiene un singolo valore.\n\nIl pacchetto R *{dplyr}* e gli altri pacchetti del tidyverse sono progettati specificamente per lavorare con dati in formato \"tidy\", permettendo agli utenti di eseguire operazioni di manipolazione e visualizzazione in modo più intuitivo ed efficiente.\n\n::: {.callout-tip collapse=true}\n## Prerequisiti\n\n- Leggere [R for Data Science (2e)](https://r4ds.hadley.nz).\n- Consultare [Data cleaning for social scientists](https://bookdown.org/f_lennert/data-prep_2days/).\n- Leggere il capitolo *Data Wrangling* di [Statistical Inference via Data Science: A ModernDive into R and the Tidyverse (Second Edition)](https://moderndive.com/v2/). \n- Consultare [Introduction to Data Science: Data Wrangling and Visualization with R](https://rafalab.dfci.harvard.edu/dsbook-part-1/) [@irizarry2024introduction]\n:::\n\n::: {.callout-caution collapse=true title=\"Preparazione del Notebook\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"code\", \"_common.R\") |> source()\n\n# Load packages\nif (!requireNamespace(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(tidyr, mice, missForest)\n```\n:::\n\n:::\n\n\n## Pipe\n\nIl pacchetto `dplyr`, così come l'intero ecosistema `tidyverse`, fa largo uso dell'operatore pipe, che consente di concatenare una sequenza di operazioni in modo leggibile ed efficiente. In R, esistono due principali notazioni per il pipe: \n\n1. **`|>`**: introdotto nativamente a partire dalla versione 4.1.0 di R.\n2. **`%>%`**: introdotto dal pacchetto `magrittr`, ed è una delle componenti centrali del `tidyverse`.\n\nEntrambi gli operatori permettono di ottenere risultati simili e, per la maggior parte degli utilizzi, possono essere considerati intercambiabili. Tuttavia, è importante sottolineare alcune differenze:\n\n- **`|>`** è integrato nel linguaggio R e non richiede pacchetti aggiuntivi.\n- **`%>%`**, essendo parte di `magrittr`, richiede che il pacchetto sia installato e caricato (`library(magrittr)` o automaticamente tramite `tidyverse`).\n\nConsideriamo l'esempio seguente (che anticipa l'uso della funzione `filter()` che descriveremo in seguito). Un'operazione comune è filtrare un data frame e calcolare la media di una colonna. Con il pipe, questa sequenza di operazioni diventa più leggibile:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Usando %>%\niris %>%\n  dplyr::filter(Species == \"setosa\") |> \n  summarise(\n    mean_sepal_length = mean(Sepal.Length)\n  ) \n#>   mean_sepal_length\n#> 1              5.01\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Usando |>\niris |> \n  dplyr::filter(Species == \"setosa\") |> \n  summarise(\n    mean_sepal_length = mean(Sepal.Length)\n  ) \n#>   mean_sepal_length\n#> 1              5.01\n```\n:::\n\n\n\n### Cosa Fa la Pipe?\n\nLa pipe è uno strumento potente che permette di collegare in modo diretto l'output di una funzione come input della funzione successiva. Questo approccio:\n\n- Riduce la necessità di creare variabili intermedie.\n- Migliora la leggibilità del codice.\n- Rende il flusso delle operazioni più chiaro e lineare.\n\nOgni funzione applicata con la pipe riceve automaticamente l'output della funzione precedente come suo primo argomento. Ciò consente di scrivere sequenze di operazioni in un formato compatto e intuitivo.\n\nEcco un altro esempio:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Utilizzo della pipe per trasformare un dataset\ndf <- data.frame(\n  id = 1:5,\n  value = c(10, 20, 30, 40, 50)\n)\n\n# Filtra i dati, seleziona colonne e calcola nuovi valori\ndf_clean <- df |>\n  dplyr::filter(value > 20) |>\n  dplyr::select(id, value) |>\n  mutate(squared_value = value^2)\n```\n:::\n\n\nIn questa sequenza, il dataset originale `df` viene filtrato, le colonne desiderate vengono selezionate e viene aggiunta una nuova colonna con il valore al quadrato.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhead(df_clean)\n#>   id value squared_value\n#> 1  3    30           900\n#> 2  4    40          1600\n#> 3  5    50          2500\n```\n:::\n\n\nIn sintesi, la pipe è uno strumento fondamentale per scrivere codice R moderno e leggibile, indipendentemente dal fatto che si utilizzi `|>` o `%>%`. \n\n## Verbi\n\nLe funzioni principali (\"verbi) di `dplyr` sono le seguenti:\n\n| Verbo dplyr  | Descrizione                                               |\n|--------------|-----------------------------------------------------------|\n| `select()`   | Seleziona colonne                                          |\n| `filter()`   | Filtra righe                                               |\n| `arrange()`  | Riordina o organizza le righe                              |\n| `mutate()`   | Crea nuove colonne                                         |\n| `summarise()`| Riassume i valori                                          |\n| `group_by()` | Consente di eseguire operazioni di gruppo                  |\n\nI verbi di `dplyr` sono suddivisi in quattro gruppi, in base all'elemento su cui operano: righe, colonne, gruppi o tabelle.\n\nInoltre, le diverse funzioni `bind_` e `_joins` permettono di combinare più tibbles (ovvero, data frame) in uno solo.\n\nPer fare un esempio prarico, usiamo nuovamente il dataset `msleep`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(msleep)\ndim(msleep)\n#> [1] 83 11\n```\n:::\n\n\nEsaminiamo i dati:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nglimpse(msleep)\n#> Rows: 83\n#> Columns: 11\n#> $ name         <chr> \"Cheetah\", \"Owl monkey\", \"Mountain beaver\", \"Greater shor…\n#> $ genus        <chr> \"Acinonyx\", \"Aotus\", \"Aplodontia\", \"Blarina\", \"Bos\", \"Bra…\n#> $ vore         <chr> \"carni\", \"omni\", \"herbi\", \"omni\", \"herbi\", \"herbi\", \"carn…\n#> $ order        <chr> \"Carnivora\", \"Primates\", \"Rodentia\", \"Soricomorpha\", \"Art…\n#> $ conservation <chr> \"lc\", NA, \"nt\", \"lc\", \"domesticated\", NA, \"vu\", NA, \"dome…\n#> $ sleep_total  <dbl> 12.1, 17.0, 14.4, 14.9, 4.0, 14.4, 8.7, 7.0, 10.1, 3.0, 5…\n#> $ sleep_rem    <dbl> NA, 1.8, 2.4, 2.3, 0.7, 2.2, 1.4, NA, 2.9, NA, 0.6, 0.8, …\n#> $ sleep_cycle  <dbl> NA, NA, NA, 0.133, 0.667, 0.767, 0.383, NA, 0.333, NA, NA…\n#> $ awake        <dbl> 11.9, 7.0, 9.6, 9.1, 20.0, 9.6, 15.3, 17.0, 13.9, 21.0, 1…\n#> $ brainwt      <dbl> NA, 0.01550, NA, 0.00029, 0.42300, NA, NA, NA, 0.07000, 0…\n#> $ bodywt       <dbl> 50.000, 0.480, 1.350, 0.019, 600.000, 3.850, 20.490, 0.04…\n```\n:::\n\n\nLe colonne, nell'ordine, corrispondono a quanto segue:\n\n| Nome colonna   | Descrizione                                     |\n|----------------|-------------------------------------------------|\n| name           | Nome comune                                     |\n| genus          | Rango tassonomico                               |\n| vore           | Carnivoro, onnivoro o erbivoro?                 |\n| order          | Rango tassonomico                               |\n| conservation   | Stato di conservazione del mammifero            |\n| sleep_total    | Quantità totale di sonno, in ore                |\n| sleep_rem      | Sonno REM, in ore                               |\n| sleep_cycle    | Durata del ciclo di sonno, in ore               |\n| awake          | Quantità di tempo trascorso sveglio, in ore     |\n| brainwt        | Peso del cervello, in chilogrammi               |\n| bodywt         | Peso corporeo, in chilogrammi                   |\n\n## Righe\n\nI verbi più importanti che operano sulle righe di un dataset sono `filter()`, che seleziona le righe da includere senza modificarne l'ordine, e `arrange()`, che cambia l'ordine delle righe senza alterare la selezione delle righe presenti.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmsleep |>\n  dplyr::filter(sleep_total < 4) |>\n  arrange(sleep_total)\n#> # A tibble: 9 × 11\n#>   name             genus         vore  order          conservation sleep_total\n#>   <chr>            <chr>         <chr> <chr>          <chr>              <dbl>\n#> 1 Giraffe          Giraffa       herbi Artiodactyla   cd                   1.9\n#> 2 Pilot whale      Globicephalus carni Cetacea        cd                   2.7\n#> 3 Horse            Equus         herbi Perissodactyla domesticated         2.9\n#> 4 Roe deer         Capreolus     herbi Artiodactyla   lc                   3  \n#> 5 Donkey           Equus         herbi Perissodactyla domesticated         3.1\n#> 6 African elephant Loxodonta     herbi Proboscidea    vu                   3.3\n#> 7 Caspian seal     Phoca         carni Carnivora      vu                   3.5\n#> 8 Sheep            Ovis          herbi Artiodactyla   domesticated         3.8\n#> 9 Asian elephant   Elephas       herbi Proboscidea    en                   3.9\n#>   sleep_rem sleep_cycle awake brainwt bodywt\n#>       <dbl>       <dbl> <dbl>   <dbl>  <dbl>\n#> 1       0.4          NA  22.1 NA       900. \n#> 2       0.1          NA  21.4 NA       800  \n#> 3       0.6           1  21.1  0.655   521  \n#> 4      NA            NA  21    0.0982   14.8\n#> 5       0.4          NA  20.9  0.419   187  \n#> 6      NA            NA  20.7  5.71   6654  \n#> 7       0.4          NA  20.5 NA        86  \n#> 8       0.6          NA  20.2  0.175    55.5\n#> 9      NA            NA  20.1  4.60   2547\n```\n:::\n\n\nPossiamo usare `filter()` speficicano più di una condizione logica.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmsleep |>\n  dplyr::filter((sleep_total < 4 & bodywt > 100) | brainwt > 1) |>\n  arrange(sleep_total)\n#> # A tibble: 7 × 11\n#>   name             genus         vore  order          conservation sleep_total\n#>   <chr>            <chr>         <chr> <chr>          <chr>              <dbl>\n#> 1 Giraffe          Giraffa       herbi Artiodactyla   cd                   1.9\n#> 2 Pilot whale      Globicephalus carni Cetacea        cd                   2.7\n#> 3 Horse            Equus         herbi Perissodactyla domesticated         2.9\n#> 4 Donkey           Equus         herbi Perissodactyla domesticated         3.1\n#> 5 African elephant Loxodonta     herbi Proboscidea    vu                   3.3\n#> 6 Asian elephant   Elephas       herbi Proboscidea    en                   3.9\n#> 7 Human            Homo          omni  Primates       <NA>                 8  \n#>   sleep_rem sleep_cycle awake brainwt bodywt\n#>       <dbl>       <dbl> <dbl>   <dbl>  <dbl>\n#> 1       0.4        NA    22.1  NA       900.\n#> 2       0.1        NA    21.4  NA       800 \n#> 3       0.6         1    21.1   0.655   521 \n#> 4       0.4        NA    20.9   0.419   187 \n#> 5      NA          NA    20.7   5.71   6654 \n#> 6      NA          NA    20.1   4.60   2547 \n#> 7       1.9         1.5  16     1.32     62\n```\n:::\n\n\n## Colonne\n\nEsistono quattro verbi principali che modificano le colonne di un dataset senza cambiare le righe:\n\n- `relocate()` cambia la posizione delle colonne;\n- `rename()` modifica i nomi delle colonne;\n- `select()` seleziona le colonne da includere o escludere;\n- `mutate()` crea nuove colonne a partire da quelle esistenti.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmsleep2 <- msleep |>\n  mutate(\n    rem_prop = sleep_rem / sleep_total * 100\n  ) |>\n  dplyr::select(name, vore, rem_prop, sleep_total) |>\n  arrange(desc(rem_prop))\n\nglimpse(msleep2)\n#> Rows: 83\n#> Columns: 4\n#> $ name        <chr> \"European hedgehog\", \"Thick-tailed opposum\", \"Giant armadi…\n#> $ vore        <chr> \"omni\", \"carni\", \"insecti\", \"omni\", \"carni\", \"omni\", \"omni…\n#> $ rem_prop    <dbl> 34.7, 34.0, 33.7, 29.2, 28.7, 27.2, 26.4, 26.2, 25.6, 25.0…\n#> $ sleep_total <dbl> 10.1, 19.4, 18.1, 8.9, 10.1, 18.0, 9.1, 10.3, 12.5, 8.4, 1…\n```\n:::\n\n\nIn questo esempio, utilizziamo `mutate()` per creare una nuova colonna `rem_prop` che rappresenta la percentuale di sonno REM sul totale del sonno. Successivamente, `select()` viene utilizzato per scegliere solo alcune colonne del dataset, e infine `desc(rem_prop)` ordina i valori di `rem_prop` in ordine decrescente, dal valore maggiore a quello minore.\n\nPer cambiare il nome di una colonna possiamo usare `rename()`. Inoltre, possiamo cambiare l'ordine delle variabili con `relocate()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmsleep2 |>\n  rename(rem_perc = rem_prop) |>\n  relocate(rem_perc, .before = name)\n#> # A tibble: 83 × 4\n#>    rem_perc name                   vore    sleep_total\n#>       <dbl> <chr>                  <chr>         <dbl>\n#>  1     34.7 European hedgehog      omni           10.1\n#>  2     34.0 Thick-tailed opposum   carni          19.4\n#>  3     33.7 Giant armadillo        insecti        18.1\n#>  4     29.2 Tree shrew             omni            8.9\n#>  5     28.7 Dog                    carni          10.1\n#>  6     27.2 North American Opossum omni           18  \n#>  7     26.4 Pig                    omni            9.1\n#>  8     26.2 Desert hedgehog        <NA>           10.3\n#>  9     25.6 Domestic cat           carni          12.5\n#> 10     25   Eastern american mole  insecti         8.4\n#> # ℹ 73 more rows\n```\n:::\n\n\n## Gruppi\n\nIl verbo `group_by()` viene utilizzato per suddividere un dataset in gruppi, in base a una o più variabili, che siano rilevanti per l'analisi. Questo permette di eseguire operazioni di sintesi su ciascun gruppo separatamente, ottenendo informazioni aggregate.\n\nAd esempio, nel codice seguente:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmsleep |>\n  group_by(order) |>\n  summarise(\n    avg_sleep = mean(sleep_total),\n    min_sleep = min(sleep_total),\n    max_sleep = max(sleep_total),\n    total = n()\n  ) |>\n  arrange(desc(avg_sleep))\n#> # A tibble: 19 × 5\n#>    order           avg_sleep min_sleep max_sleep total\n#>    <chr>               <dbl>     <dbl>     <dbl> <int>\n#>  1 Chiroptera          19.8       19.7      19.9     2\n#>  2 Didelphimorphia     18.7       18        19.4     2\n#>  3 Cingulata           17.8       17.4      18.1     2\n#>  4 Afrosoricida        15.6       15.6      15.6     1\n#>  5 Pilosa              14.4       14.4      14.4     1\n#>  6 Rodentia            12.5        7        16.6    22\n#>  7 Diprotodontia       12.4       11.1      13.7     2\n#>  8 Soricomorpha        11.1        8.4      14.9     5\n#>  9 Primates            10.5        8        17      12\n#> 10 Erinaceomorpha      10.2       10.1      10.3     2\n#> 11 Carnivora           10.1        3.5      15.8    12\n#> 12 Scandentia           8.9        8.9       8.9     1\n#> 13 Monotremata          8.6        8.6       8.6     1\n#> 14 Lagomorpha           8.4        8.4       8.4     1\n#> 15 Hyracoidea           5.67       5.3       6.3     3\n#> 16 Artiodactyla         4.52       1.9       9.1     6\n#> 17 Cetacea              4.5        2.7       5.6     3\n#> 18 Proboscidea          3.6        3.3       3.9     2\n#> 19 Perissodactyla       3.47       2.9       4.4     3\n```\n:::\n\n\n1. `group_by(order)` suddivide il dataset `msleep` in gruppi, ciascuno corrispondente a un valore distinto della variabile `order`.\n  \n2. Successivamente, `summarise()` calcola diverse statistiche per ogni gruppo:\n   - `avg_sleep` è la media del totale del sonno (`sleep_total`) all'interno di ciascun gruppo.\n   - `min_sleep` è il valore minimo di `sleep_total` in ogni gruppo.\n   - `max_sleep` è il valore massimo di `sleep_total` in ogni gruppo.\n   - `total` è il numero di osservazioni (o righe) per ciascun gruppo, calcolato con la funzione `n()`.\n\n3. Infine, `arrange(desc(avg_sleep))` ordina i risultati in ordine decrescente in base alla media del sonno totale (`avg_sleep`), mostrando prima i gruppi con la media di sonno più alta. \n\nQuesto tipo di approccio è utile quando si vuole analizzare come cambiano le caratteristiche dei dati a seconda dei gruppi specifici, fornendo una visione più dettagliata e utile.\n\n\n## Riflessioni conclusive {.unnumbered .unlisted}\n\nIl *data wrangling* è una delle fasi più importanti in qualsiasi pipeline di analisi dei dati. In questo capitolo abbiamo introdotto l'uso del pacchetto `tidyverse` di R per la manipolazione dei dati e il suo utilizzo in scenari di base. Tuttavia, il tidyverse è un ecosistema ampio e qui abbiamo trattato solo gli elementi fondamentali. Per approfondire, si consiglia di consultare ulteriori risorse come quelle disponibili sul sito web del tidyverse e il libro [*R for Data Science (2e)*](https://r4ds.hadley.nz), di cui esiste anche una [traduzione italiana](https://it.r4ds.hadley.nz).\n\n\n::: {.callout-tip title=\"Esercizio\" collapse=\"true\"}\nIn questo esercizio, utilizzerai il pacchetto `dplyr` per imparare a manipolare e trasformare i dati della SWLS (Satisfaction With Life Scale). Gli esercizi ti aiuteranno a consolidare la conoscenza dei principali verbi di `dplyr`, inclusi `filter()`, `select()`, `mutate()`, `arrange()` e `group_by()`.\n\n**Parte 1: Comprensione Teorica**\n\n1. **Cos'è un dataset \"tidy\"?**  \n   - Descrivi con parole tue cosa significa avere un dataset \"tidy\" e quali sono le sue tre caratteristiche principali.\n\n2. **Cos’è la pipe (`%>%` o `|>`) e perché è utile?**  \n   - Spiega a cosa serve l’operatore pipe e fornisci un esempio di utilizzo.\n\n3. **Quali sono i verbi principali di `dplyr`?**  \n   - Elenca e spiega brevemente i sei verbi principali di `dplyr` per la manipolazione dei dati.\n\n4. **Cosa fa il verbo `group_by()`?**  \n   - Spiega il suo scopo e come viene utilizzato in combinazione con `summarise()`.\n\n**Parte 2: Applicazione Pratica con i Dati SWLS**\n\n5. **Caricamento dei dati SWLS**  \n   - Crea un data frame in R contenente i punteggi SWLS che hai raccolto.\n\n6. **Selezione delle colonne**  \n   - Usa `select()` per mantenere solo le colonne con i punteggi degli item.\n\n7. **Filtraggio dei dati**  \n   - Usa `filter()` per selezionare solo gli individui che hanno un punteggio totale superiore a 20.\n\n8. **Creazione di una nuova colonna**  \n   - Usa `mutate()` per calcolare il punteggio totale della SWLS per ciascun individuo e salvarlo in una nuova colonna chiamata `punteggio_totale`.\n\n9. **Riordinamento dei dati**  \n   - Usa `arrange()` per ordinare il dataset in base al punteggio totale, dal più alto al più basso.\n\n10. **Raggruppamento e sintesi dei dati**  \n   - Usa `group_by()` e `summarise()` per calcolare la media e la deviazione standard del punteggio SWLS totale nel dataset.\n\n**Consegna**\n\n- Scrivi le risposte della **Parte 1** su carta.\n- Scrivi il codice e i risultati della **Parte 2** in un file `.R` e invialo come consegna.\n:::\n\n::: {.callout-tip title=\"Soluzione\" collapse=\"true\"}\n**Parte 1: Comprensione Teorica**\n\n1. **Cos'è un dataset \"tidy\"?**  \n   - Un dataset \"tidy\" è un dataset organizzato in modo sistematico per facilitare l'analisi. Le sue tre caratteristiche principali sono:\n     1. Ogni variabile è una colonna.\n     2. Ogni osservazione è una riga.\n     3. Ogni valore è una cella.\n\n2. **Cos’è la pipe (`%>%` o `|>`) e perché è utile?**  \n   - La pipe (`%>%` o `|>`) permette di concatenare più operazioni di manipolazione dati in modo leggibile ed efficiente.\n   - Esempio:\n     ```r\n     df |> \n       filter(score > 20) |> \n       select(name, score)\n     ```\n\n3. **Quali sono i verbi principali di `dplyr`?**  \n   - `select()`: Seleziona colonne.\n   - `filter()`: Filtra righe.\n   - `arrange()`: Riordina le righe.\n   - `mutate()`: Crea nuove colonne.\n   - `summarise()`: Riassume i dati.\n   - `group_by()`: Permette di raggruppare i dati.\n\n4. **Cosa fa il verbo `group_by()`?**  \n   - `group_by()` suddivide i dati in gruppi, permettendo di applicare funzioni di aggregazione con `summarise()`.\n   - Esempio:\n     ```r\n     df |> \n       group_by(gruppo) |> \n       summarise(media = mean(score), sd = sd(score))\n     ```\n\n**Parte 2: Applicazione Pratica con i Dati SWLS**\n\n5. **Caricamento dei dati SWLS**  Per svolgere l'esercizio, simuliamo i dati di 10 individui su 5 item (numeri casuali da 1 a 7):\n\n   ```r\n   set.seed(123)\n   swls <- data.frame(\n     id = 1:10,\n     item1 = sample(1:7, 10, replace = TRUE),\n     item2 = sample(1:7, 10, replace = TRUE),\n     item3 = sample(1:7, 10, replace = TRUE),\n     item4 = sample(1:7, 10, replace = TRUE),\n     item5 = sample(1:7, 10, replace = TRUE)\n   )\n   print(swls)\n   ```\n\n6. **Selezione delle colonne**  \n   ```r\n   swls_selected <- swls |> select(item1:item5)\n   ```\n\n7. **Filtraggio dei dati**  \n   ```r\n   swls_filtered <- swls |> filter(rowSums(select(swls, item1:item5)) > 20)\n   ```\n\n8. **Creazione di una nuova colonna**  \n   ```r\n   swls <- swls |> mutate(punteggio_totale = rowSums(select(swls, item1:item5)))\n   ```\n\n9. **Riordinamento dei dati**  \n   ```r\n   swls_sorted <- swls |> arrange(desc(punteggio_totale))\n   ```\n\n10. **Raggruppamento e sintesi dei dati**  \n   ```r\n   swls_summary <- swls |> \n     summarise(media = mean(punteggio_totale), sd = sd(punteggio_totale))\n   ```\n\n**Conclusione**\n\nQuesti esercizi hanno mostrato come usare `dplyr` per manipolare dati in modo efficace e leggibile.\n:::\n\n\n::: {.callout-note collapse=true title=\"Informazioni sull'ambiente di sviluppo\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.5.1 (2025-06-13)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.6.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1\n#> \n#> locale:\n#> [1] C/UTF-8/C/C/C/C\n#> \n#> time zone: Europe/Rome\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#>  [1] missForest_1.5        mice_3.18.0           pillar_1.11.0        \n#>  [4] tinytable_0.13.0      patchwork_1.3.2       ggdist_3.3.3         \n#>  [7] tidybayes_3.0.7       bayesplot_1.14.0      ggplot2_3.5.2        \n#> [10] reliabilitydiag_0.2.1 priorsense_1.1.1      posterior_1.6.1      \n#> [13] loo_2.8.0             rstan_2.32.7          StanHeaders_2.32.10  \n#> [16] brms_2.22.0           Rcpp_1.1.0            sessioninfo_1.2.3    \n#> [19] conflicted_1.2.0      janitor_2.2.1         matrixStats_1.5.0    \n#> [22] modelr_0.1.11         tibble_3.3.0          dplyr_1.1.4          \n#> [25] tidyr_1.3.1           rio_1.2.3             here_1.0.1           \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] Rdpack_2.6.4          gridExtra_2.3         inline_0.3.21        \n#>  [4] sandwich_3.1-1        rlang_1.1.6           magrittr_2.0.3       \n#>  [7] multcomp_1.4-28       snakecase_0.11.1      compiler_4.5.1       \n#> [10] systemfonts_1.2.3     vctrs_0.6.5           stringr_1.5.1        \n#> [13] pkgconfig_2.0.3       shape_1.4.6.1         arrayhelpers_1.1-0   \n#> [16] fastmap_1.2.0         backports_1.5.0       utf8_1.2.6           \n#> [19] rmarkdown_2.29        itertools_0.1-3       nloptr_2.2.1         \n#> [22] ragg_1.5.0            purrr_1.1.0           jomo_2.7-6           \n#> [25] xfun_0.53             glmnet_4.1-10         randomForest_4.7-1.2 \n#> [28] cachem_1.1.0          jsonlite_2.0.0        pan_1.9              \n#> [31] broom_1.0.9           parallel_4.5.1        R6_2.6.1             \n#> [34] stringi_1.8.7         RColorBrewer_1.1-3    rpart_4.1.24         \n#> [37] boot_1.3-32           lubridate_1.9.4       estimability_1.5.1   \n#> [40] iterators_1.0.14      knitr_1.50            zoo_1.8-14           \n#> [43] pacman_0.5.1          nnet_7.3-20           Matrix_1.7-4         \n#> [46] splines_4.5.1         timechange_0.3.0      tidyselect_1.2.1     \n#> [49] abind_1.4-8           codetools_0.2-20      curl_7.0.0           \n#> [52] doRNG_1.8.6.2         pkgbuild_1.4.8        lattice_0.22-7       \n#> [55] withr_3.0.2           bridgesampling_1.1-2  coda_0.19-4.1        \n#> [58] evaluate_1.0.5        survival_3.8-3        RcppParallel_5.1.11-1\n#> [61] rngtools_1.5.2        tensorA_0.36.2.1      checkmate_2.3.3      \n#> [64] foreach_1.5.2         stats4_4.5.1          reformulas_0.4.1     \n#> [67] distributional_0.5.0  generics_0.1.4        rprojroot_2.1.1      \n#> [70] rstantools_2.5.0      scales_1.4.0          minqa_1.2.8          \n#> [73] xtable_1.8-4          glue_1.8.0            emmeans_1.11.2-8     \n#> [76] tools_4.5.1           lme4_1.1-37           mvtnorm_1.3-3        \n#> [79] grid_4.5.1            rbibutils_2.3         QuickJSR_1.8.0       \n#> [82] colorspace_2.1-1      nlme_3.1-168          cli_3.6.5            \n#> [85] textshaping_1.0.3     svUnit_1.0.8          Brobdingnag_1.2-9    \n#> [88] V8_7.0.0              gtable_0.3.6          digest_0.6.37        \n#> [91] TH.data_1.1-4         htmlwidgets_1.6.4     farver_2.1.2         \n#> [94] memoise_2.0.1         htmltools_0.5.8.1     lifecycle_1.0.4      \n#> [97] mitml_0.4-5           MASS_7.3-65\n```\n:::\n\n:::\n\n## Bibliografia {.unnumbered .unlisted}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}