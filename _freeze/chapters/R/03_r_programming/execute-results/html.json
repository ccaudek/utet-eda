{
  "hash": "8a7b6b5c61656e29c4686ad864fd0a02",
  "result": {
    "engine": "knitr",
    "markdown": "# Programmazione {#sec-r-programming}\n\n## Introduzione {.unnumbered .unlisted}\n\nIn questo capitolo esploreremo tre strumenti fondamentali per la scrittura di codice in R: le funzioni, le istruzioni condizionali e i cicli. Questi elementi costituiscono la base per sviluppare script flessibili, efficienti e riutilizzabili, essenziali per ogni programmatore o analista che utilizza R.\n\n::: {.callout-tip collapse=true}\n## Prerequisiti\n\n- Consultare [Introduction to Data Science: Data Wrangling and Visualization with R](https://rafalab.dfci.harvard.edu/dsbook-part-1/) [@irizarry2024introduction]\n- Leggere [R for Data Science (2e)](https://r4ds.hadley.nz/).\n- Consultare la [Tidyverse style guide](https://style.tidyverse.org/).\n:::\n\n::: {.callout-caution collapse=true title=\"Preparazione del Notebook\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"code\", \"_common.R\") |> \n  source()\n\n# Load packages\nif (!requireNamespace(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(tidyr)\n```\n:::\n\n:::\n\n\n## Funzioni\n\nR offre un'ampia gamma di funzioni integrate per supportare l'analisi statistica, la manipolazione dei dati e la visualizzazione grafica, rendendolo uno strumento estremamente versatile per diverse esigenze.\n\nEsempi di funzioni comuni includono:  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Sommare numeri\nsum(1, 2, 3)  # Restituisce la somma dei numeri\n#> [1] 6\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Creare un grafico semplice\nplot(1:10, 1:10)  # Crea un grafico a dispersione dei valori\n```\n\n::: {.cell-output-display}\n![](03_r_programming_files/figure-html/unnamed-chunk-3-1.png){fig-align='center' width=85%}\n:::\n:::\n\n\nIn sostanza, una funzione è un blocco di codice progettato per svolgere un’operazione specifica. Puoi pensare a una funzione come a una \"black box\": fornisci un input (i dati), la funzione elabora l'informazione attraverso le sue istruzioni e restituisce un output (il risultato). Questo approccio modulare semplifica il lavoro, permettendo di riutilizzare e combinare facilmente diverse operazioni. \n\n### Creare Funzioni Personalizzate\n\nLa creazione di funzioni personalizzate in R è uno strumento essenziale per migliorare la programmazione, soprattutto per gestire operazioni ripetitive o complesse. Le funzioni consentono di rendere il codice più leggibile, efficiente e riutilizzabile, promuovendo un approccio organizzato e chiaro alla risoluzione dei problemi.\n\n#### Vantaggi delle Funzioni Personalizzate\n\nL'uso di funzioni personalizzate offre numerosi benefici:\n\n- **Chiarezza e leggibilità**: Un nome descrittivo permette di comprendere immediatamente lo scopo della funzione, anche a distanza di tempo o per altri utenti che leggono il codice.  \n- **Manutenzione semplificata**: Modificare il codice all'interno di una funzione aggiorna automaticamente tutte le sue occorrenze, riducendo il rischio di errori e semplificando il debugging.  \n- **Riduzione degli errori**: Si evitano gli errori tipici del copia-e-incolla, come omissioni o incoerenze nei programmi complessi.  \n- **Riutilizzabilità**: Una funzione ben progettata può essere utilizzata in più contesti o progetti, risparmiando tempo e sforzi.  \n\n#### Quando Creare una Funzione?\n\nUn buon criterio per decidere se creare una funzione è osservare se il medesimo blocco di codice viene copiato più volte. Se ti trovi a ripetere lo stesso codice più di due volte, probabilmente è il momento di creare una funzione. Questo aiuta a scrivere codice più pulito, scalabile e professionale, migliorando anche la sostenibilità del lavoro a lungo termine.\n\n### Sintassi di una Funzione\n\nLa struttura base di una funzione in R è la seguente:\n\n```r\nnome_funzione <- function(argomenti) {\n  # Corpo della funzione\n  codice\n  return(risultato)  # Facoltativo: restituisce il valore calcolato\n}\n```\n\n- **`nome_funzione`**: Nome della funzione, scelto per descrivere chiaramente la sua finalità.  \n- **`argomenti`**: Parametri necessari per eseguire le operazioni all'interno della funzione.  \n- **`codice`**: Le istruzioni che definiscono il comportamento della funzione.  \n- **`risultato`**: Il valore restituito dalla funzione. Se non si usa `return()`, R restituisce l'ultimo valore calcolato.  \n\n::: {#exm-}\n\nImmaginiamo di voler creare una funzione per sommare due numeri. \n\n```r\nsomma_due <- function(a, b) {\n  a + b  # Restituisce la somma dei due numeri\n}\n```\n\nPer utilizzarla, basta richiamarla specificando i parametri:\n\n```r\nsomma_due(5, 3)  # Restituisce 8\n```\n\nQuesto approccio aiuta a scrivere codice più leggibile e facile da gestire. Ad esempio, se in futuro volessi modificare il comportamento della somma (ad esempio, aggiungere un messaggio di log), basterà intervenire solo all’interno della funzione.\n:::\n\n::: {#exm-}\nImmaginiamo di avere un dataset con i punteggi di 10 individui su 3 subscale di un test psicometrico. L'obiettivo è:\n\n1. Creare una funzione per calcolare il punteggio totale di un individuo.\n2. Creare una funzione per trovare il massimo punteggio totale nel campione.\n3. Creare una funzione per individuare chi ha ottenuto il massimo punteggio.\n\n**Passo 1:** Simulazione dei Dati. Simuliamo i punteggi di 10 individui su 3 subscale:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Simulazione dei punteggi\nset.seed(123)\npunteggi <- data.frame(\n  individuo = paste(\"Individuo\", 1:10),\n  subscale1 = sample(30:50, 10, replace = TRUE),\n  subscale2 = sample(40:60, 10, replace = TRUE),\n  subscale3 = sample(35:55, 10, replace = TRUE)\n)\nprint(punteggi)\n#>       individuo subscale1 subscale2 subscale3\n#> 1   Individuo 1        44        44        48\n#> 2   Individuo 2        48        58        51\n#> 3   Individuo 3        43        48        45\n#> 4   Individuo 4        32        42        41\n#> 5   Individuo 5        39        47        55\n#> 6   Individuo 6        47        46        46\n#> 7   Individuo 7        40        49        49\n#> 8   Individuo 8        34        48        44\n#> 9   Individuo 9        49        58        47\n#> 10 Individuo 10        43        43        41\n```\n:::\n\n\nLa funzione `sample()` in R è utilizzata per estrarre casualmente un sottoinsieme di valori da un vettore. Nell’esempio sopra, `sample()` viene utilizzata per generare casualmente i punteggi delle subscale dei test psicometrici. \n\nNell'istruzione `subscale1 <- sample(30:50, 10, replace = TRUE)`\n\n- `30:50`: Rappresenta il vettore di numeri interi da cui vengono estratti i punteggi (valori possibili tra 30 e 50).\n- `10`: Indica che vogliamo estrarre 10 valori.\n- `replace = TRUE`: Consente che lo stesso valore possa essere estratto più volte (estrazione con ripetizione).\n\n**Passo 2:** Creazione delle Funzioni. \n\n1. **Calcolo del punteggio totale per ogni individuo**  \n   Questa funzione somma i punteggi delle subscale di un individuo:\n\n\n   ::: {.cell layout-align=\"center\"}\n   \n   ```{.r .cell-code}\n   calcola_totale <- function(subscale1, subscale2, subscale3) {\n     return(subscale1 + subscale2 + subscale3)\n   }\n   ```\n   :::\n\n\n2. **Trovare il punteggio massimo nel campione**  \n   Questa funzione accetta un vettore di punteggi totali e restituisce il valore massimo:\n\n\n   ::: {.cell layout-align=\"center\"}\n   \n   ```{.r .cell-code}\n   trova_massimo <- function(punteggi_totali) {\n     return(max(punteggi_totali))\n   }\n   ```\n   :::\n\n\n3. **Individuare l’individuo con il punteggio massimo**  \n   Questa funzione accetta un data frame con i punteggi e restituisce il nome dell’individuo con il punteggio più alto:\n\n\n   ::: {.cell layout-align=\"center\"}\n   \n   ```{.r .cell-code}\n   trova_individuo_massimo <- function(punteggi) {\n     punteggi_totali <- rowSums(punteggi[, c(\"subscale1\", \"subscale2\", \"subscale3\")])\n     indice_massimo <- which.max(punteggi_totali)\n     return(punteggi$individuo[indice_massimo])\n   }\n   ```\n   :::\n\n   \n   La funzione `which.max()` restituisce l'indice della posizione in cui si trova il valore massimo in un vettore.\n\n**Passo 3:** Applicazione delle Funzioni\n\n1. **Calcolo dei punteggi totali per ogni individuo**  \n   Applichiamo la funzione ai dati simulati:\n\n\n   ::: {.cell layout-align=\"center\"}\n   \n   ```{.r .cell-code}\n   punteggi$punteggio_totale <- with(\n     punteggi, calcola_totale(subscale1, subscale2, subscale3)\n    )\n   print(punteggi)\n   #>       individuo subscale1 subscale2 subscale3 punteggio_totale\n   #> 1   Individuo 1        44        44        48              136\n   #> 2   Individuo 2        48        58        51              157\n   #> 3   Individuo 3        43        48        45              136\n   #> 4   Individuo 4        32        42        41              115\n   #> 5   Individuo 5        39        47        55              141\n   #> 6   Individuo 6        47        46        46              139\n   #> 7   Individuo 7        40        49        49              138\n   #> 8   Individuo 8        34        48        44              126\n   #> 9   Individuo 9        49        58        47              154\n   #> 10 Individuo 10        43        43        41              127\n   ```\n   :::\n\n\n2. **Troviamo il punteggio massimo nel campione**  \n\n\n   ::: {.cell layout-align=\"center\"}\n   \n   ```{.r .cell-code}\n   massimo <- trova_massimo(punteggi$punteggio_totale)\n   print(massimo)\n   #> [1] 157\n   ```\n   :::\n\n\n3. **Troviamo chi ha il punteggio massimo**  \n\n\n   ::: {.cell layout-align=\"center\"}\n   \n   ```{.r .cell-code}\n   individuo_massimo <- trova_individuo_massimo(punteggi)\n   print(individuo_massimo)\n   #> [1] \"Individuo 2\"\n   ```\n   :::\n\n:::\n\n### Stile \n\nÈ consigliato di usare nomi di funzioni chiari e descrittivi, preferibilmente verbi (es. `compute_mean()`). Inoltre, è importante mantenere una struttura leggibile, con spazi coerenti e indentazione.\n\n\n## Istruzioni Condizionali in R\n\nLe istruzioni condizionali permettono di introdurre logica nel tuo codice. Ad esempio, l’operazione `x * y` si limita a moltiplicare i valori di `x` e `y`, senza alcuna logica aggiunta. Con le istruzioni condizionali, puoi dire al programma di eseguire diverse operazioni a seconda che una condizione sia vera (`TRUE`) o falsa (`FALSE`).\n\nL’istruzione condizionale più comune in R è `if`. Può essere letta come: **\"Se la condizione è vera, esegui un’azione\"**. Con `else`, si estende la logica: **\"Se la condizione è vera, fai qualcosa; altrimenti fai qualcos’altro\"**.\n\nLa struttura generale è questa:\n\n```r\nif (condizione) {\n  # Codice eseguito se la condizione è TRUE\n} else {\n  # Codice eseguito se la condizione è FALSE\n}\n```\n\nImmagina questa situazione:\n\n- \"Se un partecipante al test psicologico riporta un punteggio elevato sulla scala di ansia (es. > 15), consigliagli un esercizio di rilassamento. Altrimenti, non è necessario.\"\n\nVediamo come rappresentare questa situazione in R.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nanxiety_score <- 18 # Punteggio riportato dal partecipante\n\nif (anxiety_score > 15) {\n    exercise <- \"rilassamento\"\n} else {\n    exercise <- \"nessun esercizio\"\n}\n\nexercise\n#> [1] \"rilassamento\"\n```\n:::\n\n\nSe il punteggio è maggiore di 15, il risultato sarà:\n\n```\n[1] \"rilassamento\"\n```\n\nSe il punteggio è inferiore o uguale a 15, il risultato sarà:\n\n```\n[1] \"nessun esercizio\"\n```\n\n### Uso di `ifelse()`\n\nUn’alternativa più compatta a `if` e `else` è la funzione `ifelse()`, utile soprattutto per vettori. Ad esempio, supponiamo di avere i punteggi di ansia di un gruppo di partecipanti e vogliamo decidere se assegnare un esercizio di rilassamento a ciascuno:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nanxiety_scores <- c(12, 18, 9, 22, 15)\nexercises <- ifelse(anxiety_scores > 15, \"rilassamento\", \"nessun esercizio\")\n```\n:::\n\n\nIl risultato sarà:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nexercises\n#> [1] \"nessun esercizio\" \"rilassamento\"     \"nessun esercizio\" \"rilassamento\"    \n#> [5] \"nessun esercizio\"\n```\n:::\n\n\n### Creare una Funzione con Istruzioni Condizionali\n\nLe istruzioni condizionali possono essere racchiuse in una funzione per rendere il codice più flessibile e riutilizzabile. Ad esempio, supponiamo di voler personalizzare un feedback per un partecipante in base al punteggio ottenuto in un questionario:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfeedback <- function(score) {\n    if (score > 15) {\n        \"Consigliamo un esercizio di rilassamento.\"\n    } else if (score > 10) {\n        \"Monitoriamo la situazione, ma non è necessario alcun intervento.\"\n    } else {\n        \"Nessun intervento necessario.\"\n    }\n}\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfeedback(18)\n#> [1] \"Consigliamo un esercizio di rilassamento.\"\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfeedback(12)\n#> [1] \"Monitoriamo la situazione, ma non è necessario alcun intervento.\"\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfeedback(8)\n#> [1] \"Nessun intervento necessario.\"\n```\n:::\n\n\nIn conclusione, le istruzioni condizionali come `if`, `else` e `ifelse()` sono strumenti fondamentali per introdurre logica e controllo nel tuo codice. Puoi usarle per prendere decisioni, gestire errori e rendere il tuo codice più flessibile ed efficiente. Creare funzioni che incorporano queste istruzioni è un passo fondamentale per scrivere codice ordinato e riutilizzabile in contesti psicologici e non solo.\n\n### Combinare Operatori Logici in R\n\nFinora abbiamo creato funzioni abbastanza semplici e mirate. Ora proviamo a realizzare una funzione leggermente più complessa. Immaginiamo di voler determinare se una persona ha avuto **una buona giornata** basandoci su due criteri:\n\n1. **Livello di stress**: basso (`TRUE`) o alto (`FALSE`).\n2. **Livello di supporto sociale percepito**: alto (`TRUE`) o basso (`FALSE`).\n\nVogliamo creare una funzione che prenda questi due fattori e restituisca un messaggio che descrive come potrebbe essere stata la giornata della persona.\n\nEcco come possiamo costruire la funzione:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngood_day <- function(low_stress, high_support) {\n    if (low_stress == TRUE && high_support == TRUE) {\n        \"Giornata fantastica! Ti senti calmo e supportato.\"\n    } else if (low_stress == FALSE && high_support == TRUE) {\n        \"Il supporto sociale ti aiuta a gestire lo stress elevato.\"\n    } else if (low_stress == TRUE && high_support == FALSE) {\n        \"Nonostante lo stress sia basso, la mancanza di supporto sociale pesa.\"\n    } else if (low_stress == FALSE && high_support == FALSE) {\n        \"Giornata difficile: stress elevato e poco supporto sociale.\"\n    }\n}\n```\n:::\n\n\nEsempi di utilizzo.\n\nCaso 1: Stress basso e supporto sociale alto\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngood_day(low_stress = TRUE, high_support = TRUE)\n#> [1] \"Giornata fantastica! Ti senti calmo e supportato.\"\n```\n:::\n\n\nCaso 2: Stress elevato e supporto sociale alto.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngood_day(FALSE, TRUE)\n#> [1] \"Il supporto sociale ti aiuta a gestire lo stress elevato.\"\n```\n:::\n\n\nCaso 3: Stress basso e supporto sociale basso.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngood_day(TRUE, FALSE)\n#> [1] \"Nonostante lo stress sia basso, la mancanza di supporto sociale pesa.\"\n```\n:::\n\n\nCaso 4: Stress elevato e supporto sociale basso.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngood_day(FALSE, FALSE)\n#> [1] \"Giornata difficile: stress elevato e poco supporto sociale.\"\n```\n:::\n\n\nLa funzione considera tutte le combinazioni di stress e supporto sociale:\n\n1. **Stress basso e supporto alto**: giornata ideale.\n2. **Stress elevato e supporto alto**: il supporto aiuta a mitigare lo stress.\n3. **Stress basso e supporto basso**: la mancanza di supporto rovina una situazione potenzialmente buona.\n4. **Stress elevato e supporto basso**: la situazione peggiore.\n\nNell'esempio abbiamo usato i seguenti operatori logici:\n\n- **`&&` (AND logico)**: Entrambe le condizioni devono essere vere.\n- **`==` (uguale a)**: Verifica se una variabile è vera o falsa.\n\nAd esempio, questa condizione:\n\n```R\nif (low_stress == TRUE && high_support == TRUE)\n```\nverifica se il livello di stress è basso **e** il supporto sociale è alto.\n\nIn conclusione, questa funzione dimostra come combinare condizioni logiche complesse utilizzando operatori logici come `&&` (AND) e `||` (OR). Grazie a questi strumenti, possiamo gestire facilmente logiche più articolate, mantenendo il codice leggibile e funzionale.\n\n### Gli operatori Logici in R\n\nGli operatori logici sono essenziali per definire le condizioni nelle istruzioni `if`. Ecco una tabella riassuntiva con i principali operatori:\n\n| **Operatore** | **Descrizione tecnica**         | **Significato**                     | **Esempio**                        |\n|---------------|---------------------------------|-------------------------------------|-------------------------------------|\n| `&&`          | AND logico                     | Entrambe le condizioni devono essere vere | `if(cond1 == test && cond2 == test)` |\n| `||`          | OR logico                      | Almeno una condizione deve essere vera | `if(cond1 == test || cond2 == test)` |\n| `<`           | Minore di                     | X è minore di Y                    | `if(X < Y)`                        |\n| `>`           | Maggiore di                   | X è maggiore di Y                  | `if(X > Y)`                        |\n| `<=`          | Minore o uguale a             | X è minore o uguale a Y            | `if(X <= Y)`                       |\n| `>=`          | Maggiore o uguale a           | X è maggiore o uguale a Y          | `if(X >= Y)`                       |\n| `==`          | Uguale a                      | X è uguale a Y                     | `if(X == Y)`                       |\n| `!=`          | Diverso da                    | X è diverso da Y                   | `if(X != Y)`                       |\n\n## Cicli in R\n\nR è particolarmente efficace nell'eseguire attività ripetitive. Quando dobbiamo ripetere un'operazione più volte, possiamo utilizzare un **ciclo**. I cicli eseguono un insieme di istruzioni per un numero specifico di volte o fino a quando una determinata condizione non è soddisfatta. \n\nIn R esistono tre tipi principali di cicli:\n\n1. **Ciclo `for`**: ripete un'operazione per un numero definito di iterazioni.\n2. **Ciclo `while`**: continua a eseguire le istruzioni fino a quando una condizione logica è soddisfatta.\n3. **Ciclo `repeat`**: itera indefinitamente fino a quando non viene esplicitamente interrotto con un'istruzione `break`.\n\nI cicli sono strumenti essenziali in tutti i linguaggi di programmazione, ma in R il loro utilizzo dovrebbe essere valutato attentamente, poiché spesso esistono alternative più efficienti come le funzioni della famiglia `apply`.\n\n### Il ciclo `for`\n\nIl ciclo `for` è il più utilizzato per eseguire un’operazione un numero definito di volte. Ecco un esempio base:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfor (i in 1:5) {\n    print(i)\n}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n:::\n\n\n**Come funziona?**\n\n- L'indice `i` prende il primo valore della sequenza `1:5` (cioè 1).\n- Il corpo del ciclo, ovvero il codice tra `{ }`, viene eseguito.\n- Al termine di ogni iterazione, `i` assume il valore successivo nella sequenza, e il processo si ripete fino all'ultimo valore (5 in questo caso).\n\n**Aggiungere logica nel corpo del ciclo**\n\nPossiamo aggiungere operazioni all'interno del ciclo, come ad esempio sommare 1 a ogni valore:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfor (i in 1:5) {\n    print(i + 1)\n}\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n#> [1] 6\n```\n:::\n\n\n### Il ciclo `while`\n\nIl ciclo `while` continua a eseguire le istruzioni fino a quando una condizione logica è soddisfatta. Ecco un esempio:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ni <- 0\nwhile (i <= 4) {\n    i <- i + 1\n    print(i)\n}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n:::\n\n\n**Come funziona?**\n\n- La condizione logica (`i <= 4`) viene verificata prima di ogni iterazione.\n- Se la condizione è vera, il ciclo esegue il codice tra `{ }`.\n- Quando la condizione diventa falsa (`i > 4`), il ciclo si interrompe.\n\n### Ciclo `repeat`\n\nIl ciclo `repeat` esegue il codice indefinitamente, a meno che non venga interrotto con un’istruzione `break`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ni <- 0\nrepeat {\n    i <- i + 1\n    print(i)\n    if (i >= 5) {\n        break\n    }\n}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n:::\n\n\n**Quando usarlo?**\n\nIl ciclo `repeat` è raro e viene utilizzato solo in situazioni molto particolari. Nella maggior parte dei casi, `for` o `while` sono più adatti.\n\n### Evitare i cicli: la famiglia di funzioni `apply`\n\nI cicli in R sono relativamente lenti, specialmente con dataset di grandi dimensioni. Quando possibile, è preferibile usare funzioni della famiglia `apply` per ottenere lo stesso risultato in modo più efficiente e con meno rischi di errore.\n\n#### La funzione `lapply()`\n\n`lapply()` esegue una funzione su ciascun elemento di una lista o vettore e restituisce una lista con i risultati.\n\nEsempio:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlapply(0:4, function(a) {\n    a + 1\n})\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 2\n#> \n#> [[3]]\n#> [1] 3\n#> \n#> [[4]]\n#> [1] 4\n#> \n#> [[5]]\n#> [1] 5\n```\n:::\n\n\n#### La funzione `sapply()`\n\n`lapply()` restituisce una lista, ma se vuoi un vettore come output, usa `sapply()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsapply(0:4, function(a) {\n    a + 1\n})\n#> [1] 1 2 3 4 5\n```\n:::\n\n\n### Quando usare i cicli?\n\nI cicli sono utili quando:\n\n- Devi simulare modelli complessi (es. modelli ricorsivi).\n- Hai bisogno di operazioni che dipendono dai risultati delle iterazioni precedenti.\n\nIn tutti gli altri casi, considera alternative come `apply()`, `lapply()` o funzioni simili per un codice più efficiente e meno soggetto a errori.\n\n## Linee Guida per Scrivere Codice\n\nDi seguito trovi alcune linee guida per scrivere codice chiaro, conciso e riutilizzabile:\n\n1. **Evita di ripeterti**: Segui il principio *Don't Repeat Yourself* (DRY). Scrivi funzioni e utilizza funzioni come `map` (per applicare un pezzo di codice iterativamente a tutti gli elementi di un oggetto) per evitare di copiare e incollare variazioni minime dello stesso codice in più parti del progetto.\n\n2. **Segui uno stile coerente**: Adotta una guida di stile per mantenere uniformità nel tuo codice. Per R, raccomandiamo la [guida di stile](https://style.tidyverse.org/) del “tidyverse”, scritta da Hadley Wickham. Questa guida, derivata dalla Google R Style Guide, fornisce istruzioni dettagliate su sintassi del codice, nomi delle variabili, spaziature, indentazioni, commenti, convenzioni per scrivere funzioni, utilizzo delle pipe (metodo per concatenare funzioni), e altro ancora. \n\n3. **Commenta abbondantemente**: Usa i commenti (ad esempio, con `#`) per spiegare perché ogni parte del codice è necessaria e cosa fa. I commenti rendono il codice più leggibile e facilitano la manutenzione futura.\n\n4. **Testa il tuo codice**: Ogni volta che scrivi codice, verifica che funzioni come previsto. Puoi farlo scrivendo funzioni di test specifiche o controllando manualmente che l’output corrisponda alle aspettative. Abituati a pensare a eventuali *edge cases* (casi limite) in cui il tuo codice potrebbe non comportarsi come previsto.\n\n5. **Esegui una revisione del codice**: Quando possibile, fai revisionare il tuo codice da un’altra persona per individuare errori e incoerenze. Se non hai nessuno a disposizione, puoi rivedere il tuo codice autonomamente: rileggendo con attenzione, è sorprendente il numero di errori che si possono individuare!\n\nSeguendo queste linee guida, potrai scrivere codice più robusto, leggibile e facile da mantenere nel tempo.[^1]\n\n[^1]: Un’ottima introduzione alle regole di stile per un progetto di analisi dei dati è fornita in questo [capitolo](https://datamgmtinedresearch.com/style).\n\n## Riflessioni Conclusive\n\nScrivere funzioni è un passaggio essenziale per migliorare la leggibilità, l’efficienza e la riutilizzabilità del codice. Funzioni ben progettate semplificano le modifiche, riducono errori e rendono il lavoro più chiaro, sia per te stesso che per i collaboratori futuri. Se trovi che stai copiando e incollando codice più volte, è il momento di pensare a creare una funzione.\n\nLe istruzioni condizionali, come `if`, `else` e `ifelse()`, sono fondamentali per introdurre logica e controllo nel codice. Permettono di gestire scenari diversi e prendere decisioni dinamiche, migliorando la flessibilità e l’efficienza dei tuoi script. Combinando queste istruzioni con operatori logici come `&&` e `||`, puoi affrontare situazioni complesse con un codice chiaro e leggibile.\n\nI cicli sono potenti strumenti per eseguire operazioni ripetitive, ma in R il loro utilizzo dovrebbe essere limitato ai casi in cui non esistono alternative più efficienti. Le funzioni `apply()` e simili rappresentano spesso un’opzione migliore per manipolare dati in modo più rapido e leggibile.\n\n::: {.callout-tip title=\"Esercizio\" collapse=\"true\"}\nIn questo esercizio, utilizzerai R per praticare la creazione di funzioni, l’uso delle istruzioni condizionali e l’applicazione dei cicli. L'obiettivo è comprendere come scrivere codice più strutturato, riutilizzabile ed efficiente.\n\n**Parte 1: Comprensione Teorica**\n\n1. **Cos’è una funzione in R?**  \n   - Descrivi con parole tue cosa fa una funzione e perché è utile.\n\n2. **Sintassi delle funzioni**  \n   - Scrivi la struttura generale di una funzione in R.\n\n3. **Uso di istruzioni condizionali**  \n   - Qual è la differenza tra `if`, `else` e `ifelse()`? Fornisci un esempio per ciascuno.\n\n4. **Cicli in R**  \n   - Qual è la differenza tra `for`, `while` e `repeat`?  \n\n**Parte 2: Creazione ed Esecuzione in R**\n\n5. **Creazione di una funzione per calcolare il punteggio totale SWLS**  \n   - Scrivi una funzione in R chiamata `calcola_SWLS()` che accetta un vettore con 5 punteggi SWLS e restituisce il totale.\n\n6. **Condizione per determinare la soddisfazione**  \n   - Scrivi una funzione `valuta_soddisfazione()` che prende un punteggio SWLS totale e restituisce:\n     - `\"Alta soddisfazione\"` se il punteggio è sopra 24.\n     - `\"Soddisfazione moderata\"` se è tra 15 e 24.\n     - `\"Bassa soddisfazione\"` se è inferiore a 15.\n\n7. **Applicare una funzione a più individui**  \n   - Scrivi un ciclo `for` che calcola la soddisfazione per un gruppo di 5 persone e stampa il risultato.\n\n8. **Uso di `ifelse()`**  \n   - Usa `ifelse()` per determinare rapidamente se i punteggi di 5 individui indicano soddisfazione alta (`> 24`) o bassa (`≤ 24`).\n\n9. **Ciclo `while` per controllare input**  \n   - Scrivi un ciclo `while` che continua a chiedere all’utente di inserire un punteggio SWLS fino a quando non inserisce un valore valido (compreso tra 5 e 35).\n\n10. **Esportazione dei dati**  \n   - Salva in un file CSV `\"swls_results.csv\"` un data frame contenente i punteggi SWLS e la valutazione della soddisfazione.\n\n**Consegna**\n\n- Scrivi le risposte della **Parte 1** su carta.\n- Scrivi il codice e i risultati della **Parte 2** in un file `.R` e invialo come consegna.\n:::\n\n::: {.callout-tip title=\"Soluzione\" collapse=\"true\"}\n**Parte 1: Comprensione Teorica**\n\n1. **Cos’è una funzione in R?**  \n   - Una funzione è un blocco di codice che esegue un'operazione specifica. Permette di scrivere codice riutilizzabile e più organizzato.\n\n2. **Sintassi delle funzioni**  \n   ```r\n   nome_funzione <- function(argomenti) {\n     # Corpo della funzione\n     return(risultato)\n   }\n   ```\n\n3. **Uso di istruzioni condizionali**  \n   - `if`: Controlla una condizione e esegue codice solo se è vera.\n   ```r\n   if (x > 10) { print(\"Maggiore di 10\") }\n   ```\n\n   - `else`: Esegue codice alternativo se la condizione è falsa.\n   ```r\n   if (x > 10) { print(\"Maggiore di 10\") } else { print(\"10 o meno\") }\n   ```\n\n   - `ifelse()`: Alternativa vettorializzata a `if`.\n   ```r\n   y <- ifelse(x > 10, \"Alto\", \"Basso\")\n   ```\n\n4. **Cicli in R**  \n   - `for`: Itera su una sequenza.\n   ```r\n   for (i in 1:5) { print(i) }\n   ```\n\n   - `while`: Continua fino a quando una condizione è vera.\n   ```r\n   i <- 1\n   while (i <= 5) { print(i); i <- i + 1 }\n   ```\n\n   - `repeat`: Ripete fino a un `break`.\n   ```r\n   i <- 1\n   repeat { print(i); i <- i + 1; if (i > 5) break }\n   ```\n\n**Parte 2: Creazione ed Esecuzione in R**\n\n5. **Creazione della funzione per il punteggio totale SWLS**  \n   ```r\n   calcola_SWLS <- function(punteggi) {\n     return(sum(punteggi))\n   }\n   ```\n\n6. **Condizione per determinare la soddisfazione**  \n   ```r\n   valuta_soddisfazione <- function(score) {\n     if (score > 24) {\n       return(\"Alta soddisfazione\")\n     } else if (score >= 15) {\n       return(\"Soddisfazione moderata\")\n     } else {\n       return(\"Bassa soddisfazione\")\n     }\n   }\n   ```\n\n7. **Applicazione della funzione a più individui**  \n   ```r\n   punteggi_lista <- list(c(25, 27, 22, 24, 28), c(18, 20, 17, 16, 19))\n   for (punteggi in punteggi_lista) {\n     print(valuta_soddisfazione(calcola_SWLS(punteggi)))\n   }\n   ```\n\n8. **Uso di `ifelse()`**  \n   ```r\n   punteggi_totali <- c(28, 19, 15, 10, 25)\n   soddisfazione <- ifelse(punteggi_totali > 24, \"Alta\", \"Bassa\")\n   print(soddisfazione)\n   ```\n\n9. **Ciclo `while` per controllare input**  \n   ```r\n   score <- 0\n   while (score < 5 || score > 35) {\n     score <- as.numeric(readline(prompt = \"Inserisci un punteggio SWLS (5-35): \"))\n   }\n   ```\n\n10. **Esportazione dei dati**  \n   ```r\n   df <- data.frame(Punteggio = punteggi_totali, Soddisfazione = soddisfazione)\n   write.csv(df, \"swls_results.csv\", row.names = FALSE)\n   ```\n\n**Conclusione**\n\nQuesti esercizi hanno mostrato come scrivere funzioni, utilizzare condizioni e cicli per strutturare meglio il codice in R.\n:::\n\n::: {.callout-note collapse=true title=\"Informazioni sull'ambiente di sviluppo\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.5.1 (2025-06-13)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.6.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1\n#> \n#> locale:\n#> [1] C/UTF-8/C/C/C/C\n#> \n#> time zone: Europe/Rome\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#>  [1] pillar_1.11.0         tinytable_0.13.0      patchwork_1.3.2      \n#>  [4] ggdist_3.3.3          tidybayes_3.0.7       bayesplot_1.14.0     \n#>  [7] ggplot2_3.5.2         reliabilitydiag_0.2.1 priorsense_1.1.1     \n#> [10] posterior_1.6.1       loo_2.8.0             rstan_2.32.7         \n#> [13] StanHeaders_2.32.10   brms_2.22.0           Rcpp_1.1.0           \n#> [16] sessioninfo_1.2.3     conflicted_1.2.0      janitor_2.2.1        \n#> [19] matrixStats_1.5.0     modelr_0.1.11         tibble_3.3.0         \n#> [22] dplyr_1.1.4           tidyr_1.3.1           rio_1.2.3            \n#> [25] here_1.0.1           \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] svUnit_1.0.8          tidyselect_1.2.1      farver_2.1.2         \n#>  [4] fastmap_1.2.0         TH.data_1.1-4         tensorA_0.36.2.1     \n#>  [7] pacman_0.5.1          digest_0.6.37         timechange_0.3.0     \n#> [10] estimability_1.5.1    lifecycle_1.0.4       survival_3.8-3       \n#> [13] magrittr_2.0.3        compiler_4.5.1        rlang_1.1.6          \n#> [16] tools_4.5.1           knitr_1.50            bridgesampling_1.1-2 \n#> [19] htmlwidgets_1.6.4     curl_7.0.0            pkgbuild_1.4.8       \n#> [22] RColorBrewer_1.1-3    abind_1.4-8           multcomp_1.4-28      \n#> [25] withr_3.0.2           purrr_1.1.0           grid_4.5.1           \n#> [28] stats4_4.5.1          colorspace_2.1-1      xtable_1.8-4         \n#> [31] inline_0.3.21         emmeans_1.11.2-8      scales_1.4.0         \n#> [34] MASS_7.3-65           cli_3.6.5             mvtnorm_1.3-3        \n#> [37] rmarkdown_2.29        ragg_1.5.0            generics_0.1.4       \n#> [40] RcppParallel_5.1.11-1 cachem_1.1.0          stringr_1.5.1        \n#> [43] splines_4.5.1         parallel_4.5.1        vctrs_0.6.5          \n#> [46] V8_7.0.0              Matrix_1.7-4          sandwich_3.1-1       \n#> [49] jsonlite_2.0.0        arrayhelpers_1.1-0    systemfonts_1.2.3    \n#> [52] glue_1.8.0            codetools_0.2-20      distributional_0.5.0 \n#> [55] lubridate_1.9.4       stringi_1.8.7         gtable_0.3.6         \n#> [58] QuickJSR_1.8.0        htmltools_0.5.8.1     Brobdingnag_1.2-9    \n#> [61] R6_2.6.1              textshaping_1.0.3     rprojroot_2.1.1      \n#> [64] evaluate_1.0.5        lattice_0.22-7        backports_1.5.0      \n#> [67] memoise_2.0.1         broom_1.0.9           snakecase_0.11.1     \n#> [70] rstantools_2.5.0      coda_0.19-4.1         gridExtra_2.3        \n#> [73] nlme_3.1-168          checkmate_2.3.3       xfun_0.53            \n#> [76] zoo_1.8-14            pkgconfig_2.0.3\n```\n:::\n\n:::\n\n## Bibliografia {.unnumbered .unlisted}\n",
    "supporting": [
      "03_r_programming_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}