{
  "hash": "e4e7999aa0fd50788a0cac07ca9a8ed2",
  "result": {
    "engine": "knitr",
    "markdown": "# Un approccio moderno all'analisi dei dati {#sec-r}\n\n## Introduzione {.unnumbered .unlisted}\n\nNell'analisi dei dati psicologici, R non è solo uno strumento statistico avanzato, ma un vero e proprio linguaggio per organizzare il pensiero scientifico. La sua sintassi trasforma procedure complesse in passaggi *chiari, verificabili e ripetibili*, rispondendo alla crisi della replicabilità che ha coinvolto la psicologia negli ultimi anni [@obels2020analysis]. Imparare R significa quindi acquisire un metodo di lavoro rigoroso e trasparente.\n\n### Panoramica del capitolo {.unnumbered .unlisted}\n\n- Installare R e RStudio.\n- Creare e gestire progetti in RStudio.\n- Manipolare oggetti e vettori in R.\n- Utilizzare funzioni e lavorare con dati mancanti.\n- Estrarre e gestire sottoinsiemi di dati.\n- Apprezzare l'importanza di rendere riproducibile l'analisi dei dati, condividendone ogni passaggio.\n\n\n::: {.callout-tip collapse=true}\n## Prerequisiti\n\n- Leggere attentamene l'@sec-apx-sums. \n- Leggere il capitolo *Getting Started with Data in R* di [Statistical Inference via Data Science: A ModernDive into R and the Tidyverse (Second Edition)](https://moderndive.com/v2/), capitoli 1.1-1.3.\n- Consultare [Introduction to Data Science: Data Wrangling and Visualization with R](https://rafalab.dfci.harvard.edu/dsbook-part-1/) [@irizarry2024introduction]\n- Consultare [R for Data Science (2e)](https://r4ds.hadley.nz/) [@wickham2023r].\n- Consultare [R Programming for Data Science](https://bookdown.org/rdpeng/rprogdatascience/), capitoli 3-4.\n:::\n\n::: {.callout-caution collapse=true title=\"Preparazione del Notebook\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"code\", \"_common.R\") |> \n  source()\n\n# Load packages\nif (!requireNamespace(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(tidyr)\n```\n:::\n\n:::\n\n\n## La Sintassi di R come garanzia di trasparenza\n\nA differenza dei software a menu grafici (come Excel o SPSS), dove le operazioni restano \"nascoste\" dietro click del mouse, R richiede di descrivere esplicitamente ogni passaggio. Prendiamo questo esempio base:\n\n```r\ndati <- read.csv(\"esperimento1.csv\")\nmodello <- lm(risposta ~ trattamento, data = dati)\n```\nQuesto semplice script realizza tre cose fondamentali:\n\n1. **Documentazione automatica:** Ogni operazione resta tracciata nel codice.\n2. **Verifica immediata:** È possibile ispezionare ogni passaggio (Cosa contiene dati? Come è definito modello?).\n3. **Modifiche controllate:** Cambiare un parametro (es. il file di input) non richiede di rifare tutta l'analisi manualmente.\n\n### Perché R favorisce la replicabilità\n\nTre caratteristiche di R facilitano direttamente la replicabilità:\n\n1. **Struttura basata su script**:\n   Scrivere codice in file `.R` o `.qmd` crea una traccia completa e ordinata dell’analisi, integrando:\n   \n    - istruzioni eseguibili,\n    - annotazioni metodologiche,\n    - visualizzazione dei risultati.\n\n2. **Gestione esplicita dei pacchetti**:  \n   Comandi come `library(lme4)` o `install.packages(\"brms\")` rendono esplicite tutte le risorse usate, evitando il classico \"Sul mio computer funzionava!\".\n\n3. **Literate programming tramite R Markdown**:  \n   La combinazione di codice, testo narrativo e risultati dinamici [@knuth1984literate] in documenti Quarto (o R Markdown) consente di generare report che combinano:\n   \n   - testo esplicativo,\n   - analisi eseguibile,\n   - risultati dinamici (grafici, tabelle).\n\n### Buone abitudini da adottare subito\n\n1. **Nomi descrittivi**  \n   Utilizzare sempre nomi chiari per oggetti e dati:\n\n   ```r\n   # Da evitare\n   x <- read.csv(\"file1.csv\")  \n\n   # Preferibile\n   demographics_data <- read.csv(\"demographic_questionnaire.csv\")  \n   ```\n\n2. **Salvataggio progressivo delle modifiche (versionamento)**  \n   R permette di salvare e tenere traccia delle modifiche ai file con sistemi come Git. Non è necessario impararlo subito, ma è utile sapere che strumenti come [GitHub](https://github.com/) consentono facilmente di archiviare versioni successive del proprio lavoro, facilitando il recupero di versioni precedenti in caso di necessità.\n\n3. **Checklist pre-invio**  \n   Prima di condividere un'analisi, è buona norma verificare:\n   \n   - eseguire lo script integralmente (Ctrl+Shift+Enter su RStudio);\n   - controllare che i percorsi dei file siano corretti (es.: \"Il file `dati.csv` si trova nella cartella giusta?\");\n   - aggiornare tutti i pacchetti installati con `update.packages(ask = FALSE)`.\n\nQueste pratiche rendono il codice più robusto, l’analisi più affidabile e i risultati più facilmente verificabili.\n\n### Perché queste regole contano nella ricerca psicologica\n\nL'apprendimento di R va oltre l'acquisizione di competenze tecniche. Ogni scelta sintattica riflette un principio scientifico:\n\n| Elemento del codice | Principio metodologico           |\n|----------------------|----------------------------------|\n| `set.seed(123)`      | Controllo delle fonti di casualità |\n| `dplyr::filter()`    | Tracciabilità delle esclusioni   |\n| `APA_style()`        | Standardizzazione della reportistica |\n\nIn un contesto dove il 50% degli studi psicologici mostra difficoltà di replicazione [@open2015estimating], R offre un framework per costruire ricerche solide fin dalla fase di progettazione.\n\n### Prossimi passi\n\n1. **Scarica e installa R.**  \n   Vai al sito ufficiale di CRAN (https://cran.r-project.org/), scegli la versione per il tuo sistema operativo (Windows, Mac o Linux) e segui le istruzioni di installazione.\n\n2. **Scarica e installa RStudio.**  \n   Dopo aver installato R, scarica RStudio dal sito ufficiale (https://posit.co/download/rstudio-desktop/). Scegli la versione gratuita \"RStudio Desktop\" e segui le istruzioni per il tuo sistema operativo.\n\nUna spiegazione dettagliata del processo di installazione di R e RStudio è disponibile in @okoye2024introduction.\n\n## Panoramica sull'interfaccia di RStudio\n\nRStudio rende l’uso di R più intuitivo grazie alla sua interfaccia divisa in quattro pannelli principali:\n\n- **Pannello degli script**: Qui puoi scrivere e modificare i tuoi script, cioè sequenze di comandi salvabili per analisi ripetibili e organizzate.\n- **Console**: Esegue i comandi scritti direttamente o lanciati dagli script, mostrando risultati, messaggi e errori.\n- **Pannello dell’ambiente**: Mostra i dataset, le variabili e gli oggetti caricati nella sessione di lavoro, permettendoti di gestire facilmente i dati.\n- **Pannello grafici/aiuto/file**: Visualizza grafici, fornisce accesso alla documentazione di R e consente di navigare tra file e cartelle sul tuo sistema.\n\n## Creare un nuovo progetto in RStudio\n\n**Avviare un nuovo progetto**  \nDal menu di RStudio, seleziona *File > New Project...* per creare un nuovo progetto. I progetti in RStudio sono uno strumento efficace per organizzare il lavoro relativo a una specifica analisi o domanda di ricerca. All'interno di un progetto puoi raccogliere script, file di dati e output, mantenendo tutto ben strutturato.\n\n**Scegliere la posizione del progetto**  \nPuoi creare una nuova directory dedicata al progetto oppure associare il progetto a una directory esistente. Organizzare i progetti in cartelle dedicate aiuta a mantenere i file in ordine e a utilizzare percorsi relativi, rendendo il tuo lavoro più facile da condividere con collaboratori e più portabile tra diversi sistemi. \n\nQuesta organizzazione è particolarmente utile per evitare confusione e assicurarsi che tutti i file necessari siano facilmente accessibili e collegati al progetto corretto.\n\n## Concetti di base nella programmazione in R\n\nIniziare a usare R, soprattutto per chi si avvicina per la prima volta a questo linguaggio nel contesto della psicologia, significa comprendere i concetti fondamentali che ne costituiscono la base. Questo capitolo introduce i principi essenziali della programmazione in R, tra cui:\n\n- La comprensione della *sintassi di R*.\n- La familiarizzazione con i principali *tipi di dati* e *strutture*. \n- L’acquisizione delle *operazioni di base*.\n\nQuesti concetti sono fondamentali per manipolare efficacemente i dati e condurre analisi statistiche, rappresentando il punto di partenza per sfruttare al meglio le potenzialità di R.\n\n## Oggetti in R  \n\nIn R, tutto è un *oggetto*: dai numeri e stringhe di testo più semplici fino a strutture più complesse come vettori, data frame, funzioni, modelli statistici o persino grafici. Un oggetto in R è semplicemente un contenitore che memorizza un valore o una serie di valori, permettendoti di manipolarli e riutilizzarli nel codice.  \n\n### Creare oggetti  \n\nPer creare un oggetto, è necessario assegnargli un nome e un valore utilizzando l’operatore di assegnazione `<-` (consigliato) o `=` (meno utilizzato):  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_obj <- 48\n```\n:::\n\nIn questo esempio, abbiamo creato un oggetto chiamato `my_obj` e gli abbiamo assegnato il valore 48. Ora questo numero è memorizzato con quel nome e può essere richiamato facilmente.  \n\nPer visualizzare il valore di un oggetto, basta scriverne il nome e premere *Invio*:  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_obj\n#> [1] 48\n```\n:::\n\n\n#### Dove vengono salvati gli oggetti?  \n\nGli oggetti creati vengono memorizzati nell'*ambiente di lavoro* (workspace) e restano disponibili finché non vengono rimossi o finché la sessione di R non viene chiusa. Se stai usando RStudio, puoi vedere tutti gli oggetti attualmente presenti nella scheda *Environment*, dove vengono mostrati con dettagli come tipo, lunghezza e valore.  \n\n#### Perché gli oggetti sono importanti?  \n\nLavorare con oggetti in R permette di:  \n\n- **Riutilizzare dati e risultati** senza doverli digitare nuovamente.  \n- **Organizzare il codice in modo chiaro e leggibile**, rendendo le analisi più strutturate.  \n- **Manipolare facilmente i dati**, combinando, trasformando e analizzando gli oggetti in base alle esigenze.  \n\n#### Stringhe\n\nÈ possibile assegnare a un oggetto anche una stringa di testo, racchiudendola tra virgolette:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_obj2 <- \"R è fantastico\"\nmy_obj2\n#> [1] \"R è fantastico\"\n```\n:::\n\nSe dimentichi le virgolette, R mostrerà un errore.\n\n#### Modificare oggetti\n\nPer modificare il valore di un oggetto esistente, basta riassegnarlo:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_obj2 <- 1024\n```\n:::\n\nOra il tipo di `my_obj2` è cambiato da carattere a numerico. È anche possibile usare oggetti per crearne di nuovi:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_obj3 <- my_obj + my_obj2\nmy_obj3\n#> [1] 1072\n```\n:::\n\n\n#### Manipolare oggetti\n\nSe provi a sommare oggetti di tipo diverso, R restituirà un errore:\n\n```\nchar_obj <- \"ciao\"\nchar_obj2 <- \"mondo\"\nchar_obj3 <- char_obj + char_obj2\n#> Error in char_obj + char_obj2 : non-numeric argument to binary operator\n```\nQuando incontri errori come questo, chiedi a AI la spiegazione del messaggio, per esempio: \"non-numeric argument to binary operator error + r\". Un errore comune è anche:\n\n```\nmy_obj <- 48\nmy_obj4 <- my_obj + no_obj\n#> Error: object 'no_obj' not found\n```\nR segnala che `no_obj` non è stato definito e, di conseguenza, l’oggetto `my_obj4` non è stato creato.\n\n## Nomi degli oggetti\n\nAttribuire nomi agli oggetti potrebbe sembrare un dettaglio secondario, ma è fondamentale scegliere nomi *brevi* e *informativi*. Un buon nome migliora la leggibilità del codice e ne facilita la manutenzione. È importante adottare uno [stile](https://style.tidyverse.org) coerente, come uno dei seguenti:\n\n- **Snake case**: `output_summary`  \n- **Dot case**: `output.summary`  \n- **Camel case**: `outputSummary`  \n\nIn questo corso useremo lo stile più diffuso, *Snake Case*, che separa le parole con il carattere di sottolineatura `_`.\n\nCi sono alcune regole fondamentali da rispettare nella scelta dei nomi:  \n\n1. Non possono iniziare con un numero (ad esempio, `2my_variable` non è valido).  \n2. Non possono contenere caratteri speciali come `&`, `^`, `/`, ecc.  \n3. Evita di usare parole riservate (ad esempio, `TRUE`, `NA`) o nomi di funzioni esistenti (ad esempio, `data`).\n\nEsempio di cosa *non fare*:\n\n```r\ndata <- read.table(\"mydatafile\", header = TRUE) # `data` è già una funzione!\n```\n\n## Commenti\n\nI commenti sono uno strumento essenziale per rendere il codice più chiaro e comprensibile, sia per te stesso sia per altri. Nel linguaggio R, i commenti iniziano con il simbolo `#`, e tutto ciò che lo segue sulla stessa riga viene *ignorato dall’interprete* durante l’esecuzione.\n\n### Perché commentare?\n\nI commenti servono a spiegare *perché* il codice è scritto in un certo modo, non solo *come* funziona (questo è evidente leggendo il codice). Una buona pratica consiste nel commentare le decisioni o i passaggi che non risultano immediatamente evidenti. \n\nAd esempio, invece di scrivere un commento ridondante come:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Assegno 42 alla variabile x\nx <- 42\n```\n:::\n\nè più utile fornire un contesto:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Valore iniziale scelto per semplificare i calcoli successivi\nx <- 42\n```\n:::\n\n\n### Vantaggi\n\nCommentare in modo appropriato aiuta a: \n\n- *Ridurre il tempo* necessario per comprendere o modificare il codice, anche mesi o anni dopo averlo scritto.  \n- Facilitare la collaborazione con altri, rendendo il codice leggibile e accessibile.  \n- Migliorare la *manutenibilità* e il riutilizzo del codice.  \n\nUn codice ben commentato non è solo più facile da leggere, ma anche più professionale e robusto nel lungo termine.\n\n## Usare R come calcolatore\n\nR può essere utilizzato come un semplice calcolatore digitando direttamente nella console numeri e operatori aritmetici per eseguire operazioni come somma, sottrazione, moltiplicazione e divisione (`+`, `-`, `*`, `/`). Questo lo rende uno strumento immediato e versatile per calcoli di base e avanzati.\n\n::: {#exm-swls-1item}\nLa *Satisfaction With Life Scale* (SWLS) contiene 5 item, ciascuno valutato con una scala Likert a 7 punti, dove:  \n\n1 = \"completamente in disaccordo\" e 7 = \"completamente d'accordo\".\n\nGli item sono:  \n\n1. Per la maggior parte, la mia vita si avvicina al mio ideale.  \n2. Le mie condizioni di vita sono eccellenti.  \n3. Sono soddisfatto della mia vita.  \n4. Fino ad ora, ho ottenuto le cose importanti che voglio nella vita.  \n5. Se potessi vivere la mia vita di nuovo, non cambierei quasi nulla.  \n\nSupponiamo che un individuo risponda nel seguente modo: \n\n- Item 1: 5  \n- Item 2: 3  \n- Item 3: 4  \n- Item 4: 2  \n- Item 5: 2  \n\nIl punteggio totale sulla SWLS si calcola sommando i punteggi di ciascun item:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsogg1 <- 5 + 3 + 4 + 2 + 2 \nsogg1\n#> [1] 16\n```\n:::\n\n:::\n\n::: {#exm-}\nIl *Body Mass Index (BMI)* si calcola dividendo il peso, in chilogrammi, per il quadrato dell'altezza, in metri.  \nLa formula è:  \n\n$$ \n\\text{BMI} = \\frac{\\text{Peso (kg)}}{\\text{Altezza (m)}^2} .\n$$\n\nSupponiamo che un individuo pesi *79000 grammi* (79 kg) e sia alto *176 cm*. Il calcolo in R sarà:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbmi <- (79000 / 1000) / (176 / 100)^2\nbmi\n#> [1] 25.5\n```\n:::\n\n:::\n\n**Nota.**\nL'uso di parentesi è fondamentale per garantire che le operazioni vengano eseguite nell'ordine corretto. In R, come in matematica, le operazioni racchiuse tra parentesi hanno la precedenza rispetto ad altre operazioni. Ad esempio, nel calcolo del BMI, abbiamo usato le parentesi per calcolare prima la conversione dei valori nell'unità di misura appropriata.\n\n## Ordine di precedenza degli operatori\n\nLe operazioni algebriche vengono eseguite in una particolare sequenza in R, nota come *ordine di precedenza degli operatori*. Questo ordine determina quali operazioni vengono eseguite per prime quando un'espressione include più operatori. In assenza di parentesi, l'ordine di precedenza è il seguente (dal più alto al più basso):\n\n1. **Parentesi**: Le operazioni racchiuse tra parentesi `()` vengono eseguite per prime. Questo permette di sovrascrivere l'ordine naturale delle operazioni.\n\n\n   ::: {.cell layout-align=\"center\"}\n   \n   ```{.r .cell-code}\n   result <- (2 + 3) * 4  # Risultato: 20\n   ```\n   :::\n\n\n2. **Esponenziazione**: L'operatore `^` viene eseguito dopo le parentesi.\n\n\n   ::: {.cell layout-align=\"center\"}\n   \n   ```{.r .cell-code}\n   result <- 2^3  # Risultato: 8\n   ```\n   :::\n\n\n3. **Segni unari**: Il segno meno `-` o più `+` applicato a un singolo valore.\n\n\n   ::: {.cell layout-align=\"center\"}\n   \n   ```{.r .cell-code}\n   result <- -3 + 5  # Risultato: 2\n   ```\n   :::\n\n\n4. **Moltiplicazione, divisione e modulo**: Gli operatori `*`, `/`, `%/%` (divisione intera) e `%%` (resto) hanno la stessa precedenza e vengono eseguiti da sinistra a destra.\n\n\n   ::: {.cell layout-align=\"center\"}\n   \n   ```{.r .cell-code}\n   result <- 10 / 2 * 3  # Risultato: 15\n   result <- 10 %% 3     # Risultato: 1\n   ```\n   :::\n\n\n5. **Addizione e sottrazione**: Gli operatori `+` e `-` vengono eseguiti dopo quelli di moltiplicazione/divisione.\n\n\n   ::: {.cell layout-align=\"center\"}\n   \n   ```{.r .cell-code}\n   result <- 5 + 3 - 2  # Risultato: 6\n   ```\n   :::\n\n\n6. **Operatori di assegnazione**: Gli operatori `<-`, `->`, `=`, che assegnano valori a variabili, vengono valutati per ultimi.\n\n\n   ::: {.cell layout-align=\"center\"}\n   \n   ```{.r .cell-code}\n   x <- 2 + 3 * 4  # Risultato: 14\n   ```\n   :::\n\n\n**Note importanti:**\n\n- *Associazione a sinistra*: La maggior parte degli operatori in R viene valutata da sinistra a destra (ad esempio, `+`, `*`, `/`).\n- *Uso delle parentesi*: Quando l'ordine di precedenza non è immediatamente chiaro o si vuole assicurare un ordine specifico, è sempre buona pratica usare le parentesi.\n\nCapire l'ordine di precedenza è fondamentale per evitare errori logici e garantire che il codice funzioni come previsto.\n\n## Funzioni\n\nFino ad ora abbiamo creato oggetti semplici assegnando loro direttamente un valore. Con l'aumento dell'esperienza in R, potresti voler creare oggetti più complessi. Per aiutarti, R offre numerose funzioni già disponibili nella sua installazione di base, e altre possono essere aggiunte installando pacchetti. Una funzione è un insieme di istruzioni che eseguono un compito specifico. Inoltre, è possibile creare funzioni personalizzate.\n\n### La funzione `c()` per creare vettori\n\nLa prima funzione utile da imparare è `c()`, che serve a concatenare valori in un *vettore*. Ad esempio:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec <- c(2, 3, 1, 6, 4, 3, 3, 7)\n```\n:::\n\nQuesto codice crea un oggetto chiamato `my_vec` che contiene una sequenza di numeri. Alcuni concetti fondamentali sulle funzioni in R:\n\n1. *Nome e parentesi*: Le funzioni in R sono sempre seguite da parentesi tonde `()`.\n2. *Argomenti*: Gli elementi passati alla funzione (tra le parentesi) ne personalizzano il comportamento e sono separati da virgole.\n\nPer vedere il contenuto del vettore:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec\n#> [1] 2 3 1 6 4 3 3 7\n```\n:::\n\n\n### Funzioni per analizzare vettori\n\nPuoi utilizzare altre funzioni per calcolare statistiche sul vettore:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(my_vec)    # Media\n#> [1] 3.62\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvar(my_vec)     # Varianza\n#> [1] 3.98\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsd(my_vec)      # Deviazione standard\n#> [1] 2\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlength(my_vec)  # Numero di elementi\n#> [1] 8\n```\n:::\n\nPuoi anche salvare i risultati in nuovi oggetti per riutilizzarli:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvec_mean <- mean(my_vec)\nvec_mean\n#> [1] 3.62\n```\n:::\n\n\n::: {.callout-note title=\"Concetto Chiave\" collapse=\"true\"}\nLa varianza e la deviazione standard sono misure statistiche descrittive che sintetizzano in un unico valore numerico la variabilità di un insieme di dati. Questi indici, che verranno approfonditi nel @sec-central-tendency-variability, forniscono informazioni su quanto i valori di un dataset siano simili o diversi tra loro.\n\nIn particolare:\n\n- la varianza e la deviazione standard sono pari a 0 quando tutti i valori nel dataset sono identici, indicando assenza di variabilità;\n- assumono valori più elevati all'aumentare delle differenze tra i dati, segnalando una maggiore dispersione.\n\nPer i nostri scopi attuali, è sufficiente comprendere che queste misure descrivono il grado di diversità o omogeneità dei dati.\n:::\n\n### Creare sequenze regolari\n\nPer creare sequenze di numeri in passi regolari, puoi usare i seguenti comandi.\n\n*Simbolo `:`* per sequenze semplici:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_seq <- 1:10\nmy_seq\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n\n*Funzione `seq()`* per maggiore controllo:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_seq2 <- seq(from = 1, to = 5, by = 0.5)\nmy_seq2\n#> [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0\n```\n:::\n\n\n### Ripetere valori\n\nPuoi ripetere valori o sequenze con la funzione `rep()`.\n\nRipetere un valore:\n  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_seq3 <- rep(2, times = 10)\nmy_seq3\n#>  [1] 2 2 2 2 2 2 2 2 2 2\n```\n:::\n\nRipetere una sequenza:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_seq5 <- rep(1:5, times = 3)\n```\n:::\n\nRipetere ogni elemento di una sequenza:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_seq6 <- rep(1:5, each = 3)\nmy_seq6\n#>  [1] 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5\n```\n:::\n\n\n### Annidare funzioni\n\nÈ possibile combinare funzioni per creare comandi più complessi, come nell'esempio:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_seq7 <- rep(c(3, 1, 10, 7), each = 3)\nmy_seq7\n#>  [1]  3  3  3  1  1  1 10 10 10  7  7  7\n```\n:::\n\nPer maggiore leggibilità, puoi separare i passaggi:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nin_vec <- c(3, 1, 10, 7)\nmy_seq7 <- rep(in_vec, each = 3)\nmy_seq7\n#>  [1]  3  3  3  1  1  1 10 10 10  7  7  7\n```\n:::\n\nQuesta pratica facilita la comprensione del codice e lo rende più chiaro.\n\n## Lavorare con i Vettori in R \n\nIn R, i vettori sono uno degli elementi fondamentali per manipolare, riassumere e ordinare i dati. Qui trovi una panoramica su come estrarre, sostituire, ordinare, lavorare con dati mancanti e sfruttare la vettorizzazione dei vettori.\n\n### Estrarre elementi da un vettore\n\nPuoi estrarre uno o più elementi da un vettore usando le parentesi quadre `[ ]`.\n\n*Per posizione*: Specifica la posizione degli elementi.  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec <- c(2, 3, 1, 6, 4, 3, 3, 7)\nmy_vec[3]  # Terzo elemento\n#> [1] 1\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec[c(1, 5, 6)]  # Elementi 1°, 5° e 6°\n#> [1] 2 4 3\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec[3:8]  # Da 3° a 8°\n#> [1] 1 6 4 3 3 7\n```\n:::\n\n\n*Con condizioni logiche*: Usa espressioni logiche per selezionare elementi.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec[my_vec > 4]  # Elementi > 4\n#> [1] 6 7\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec[my_vec <= 4]  # Elementi ≤ 4\n#> [1] 2 3 1 4 3 3\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec[my_vec != 4]  # Elementi diversi da 4\n#> [1] 2 3 1 6 3 3 7\n```\n:::\n\n\n*Operatori logici*: Combina condizioni con `&` (AND) e `|` (OR).  \n   \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec[my_vec > 2 & my_vec < 6]  # Tra 2 e 6\n#> [1] 3 4 3 3\n```\n:::\n\n\n### Sostituire elementi in un vettore\n\nPuoi modificare i valori di un vettore usando `[ ]` e l'operatore `<-`.\n\n*Un singolo elemento*:  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec[4] <- 500  # Cambia il 4° elemento\nmy_vec\n#> [1]   2   3   1 500   4   3   3   7\n```\n:::\n\n\n*Più elementi*: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec[c(6, 7)] <- 100  # Cambia il 6° e 7° elemento\nmy_vec\n#> [1]   2   3   1 500   4 100 100   7\n```\n:::\n\n\n*Con condizioni logiche*:  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec[my_vec <= 4] <- 1000  # Cambia valori ≤ 4\nmy_vec\n#> [1] 1000 1000 1000  500 1000  100  100    7\n```\n:::\n\n\n### Ordinare un vettore\n\n*Dal più piccolo al più grande*:  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvec_sort <- sort(my_vec)\nvec_sort\n#> [1]    7  100  100  500 1000 1000 1000 1000\n```\n:::\n\n\n*Dal più grande al più piccolo*:  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvec_sort2 <- sort(my_vec, decreasing = TRUE)\nvec_sort2\n#> [1] 1000 1000 1000 1000  500  100  100    7\n```\n:::\n\n\n*Ordinare un vettore in base a un altro*: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nheight <- c(180, 155, 160, 167, 181)\np.names <- c(\"Joanna\", \"Charlotte\", \"Helen\", \"Karen\", \"Amy\")\nheight_ord <- order(height)\nnames_ord <- p.names[height_ord]\nnames_ord\n#> [1] \"Charlotte\" \"Helen\"     \"Karen\"     \"Joanna\"    \"Amy\"\n```\n:::\n\n\n## Operazioni vettoriali e vettorizzazione in R\n\nLa vettorializzazione è una delle caratteristiche più potenti di R, che consente di applicare operazioni o funzioni direttamente a tutti gli elementi di un vettore in modo simultaneo, senza dover ricorrere a cicli espliciti. Questo approccio rende il codice più conciso, leggibile ed efficiente, sfruttando al meglio le capacità intrinseche del linguaggio.\n\n### Operazioni aritmetiche su vettori\n\nLe operazioni algebriche in R, come addizione, sottrazione, moltiplicazione e divisione, sono vettorizzate. Questo significa che ogni operazione viene applicata \"elemento per elemento\" al vettore.\n\nConsideriamo ad esempio il seguente vettore:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec <- c(3, 5, 7, 1, 9, 20)\n```\n:::\n\n\nSe vogliamo moltiplicare ciascun elemento di `my_vec` per 5, possiamo scrivere:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec * 5\n#> [1]  15  25  35   5  45 100\n```\n:::\n\n\nAnalogamente, possiamo effettuare altre operazioni algebriche, come divisione o elevamento a potenza:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec / 2\n#> [1]  1.5  2.5  3.5  0.5  4.5 10.0\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec^2\n#> [1]   9  25  49   1  81 400\n```\n:::\n\n\nQueste operazioni vengono applicate automaticamente a ciascun elemento del vettore, senza dover iterare su di essi.\n\n### Operazioni elemento per elemento tra due vettori\n\nLa vettorializzazione consente anche di eseguire operazioni tra due vettori, applicandole elemento per elemento. Supponiamo di avere un secondo vettore:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec2 <- c(17, 15, 13, 19, 11, 0)\n```\n:::\n\n\nSe vogliamo sommare i due vettori, possiamo scrivere:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec + my_vec2\n#> [1] 20 20 20 20 20 20\n```\n:::\n\n\nIn questo caso, il primo elemento di `my_vec` viene sommato al primo elemento di `my_vec2`, il secondo elemento al secondo, e così via.\n\n::: {#exm-}\nDi seguito mostriamo come calcolare i punteggi totali per 10 individui che hanno risposto ai 5 item della *Satisfaction With Life Scale* (SWLS), utilizzando le formule e l'aritmetica vettorializzata di R. \n\n**Step 1:** Definiamo i punteggi per ciascun item. Ogni vettore contiene i punteggi dati dai 10 individui a uno specifico item della scala:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Punteggi dei 10 individui per ciascun item\nitem1 <- c(5, 4, 6, 7, 3, 2, 5, 6, 4, 7)\nitem2 <- c(3, 2, 4, 6, 2, 1, 4, 5, 3, 6)\nitem3 <- c(4, 5, 6, 5, 3, 2, 5, 7, 4, 5)\nitem4 <- c(2, 3, 4, 3, 2, 1, 3, 4, 2, 5)\nitem5 <- c(2, 2, 3, 4, 1, 1, 3, 3, 2, 4)\n```\n:::\n\n\nI valori 5, 3, 4, 2, 2 sono i punteggi del primo individuo sui 5 item; i punteggio 4, 2, 5, 3, 2 sono i punteggi del secondo individuo sui 5 item, e così via.\n\n**Step 2:** Sommiamo i punteggi per calcolare il totale. Il punteggio totale di ciascun individuo è la somma dei punteggi relativi ai 5 item. Formalmente, per l'individuo $i$ ($i = 1, 2, \\ldots, 10$), il punteggio totale è calcolato come:\n\n$$\n\\text{PunteggioTotale}_i = \\text{item1}_i + \\text{item2}_i + \\text{item3}_i + \\text{item4}_i + \\text{item5}_i .\n$$\n\nIn R, possiamo sommare i vettori direttamente grazie all'aritmetica vettorializzata:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Calcolo dei punteggi totali per ciascun individuo\ntotal_scores <- item1 + item2 + item3 + item4 + item5\ntotal_scores\n#>  [1] 16 16 23 25 11  7 20 25 15 27\n```\n:::\n\n\nIl risultato è un vettore con i punteggi totali per ciascun individuo.\n\n\n**Step 3:** Mostriamo i risultati. Per organizzare meglio i dati, creiamo una tabella che associa i punteggi totali agli individui:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Creiamo una tabella con i punteggi totali\nindividui <- paste(\"Individuo\", 1:10)\nrisultati_swls <- data.frame(Individuo = individui, PunteggioTotale = total_scores)\nprint(risultati_swls)\n#>       Individuo PunteggioTotale\n#> 1   Individuo 1              16\n#> 2   Individuo 2              16\n#> 3   Individuo 3              23\n#> 4   Individuo 4              25\n#> 5   Individuo 5              11\n#> 6   Individuo 6               7\n#> 7   Individuo 7              20\n#> 8   Individuo 8              25\n#> 9   Individuo 9              15\n#> 10 Individuo 10              27\n```\n:::\n\n\nSpiegazione delle operazioni:\n\n1. Ogni vettore contiene i punteggi di 10 individui per un dato item. Ad esempio, il vettore `item1` contiene i punteggi relativi al primo item, e così via.\n\n2. Grazie all'aritmetica vettorializzata, quando sommiamo i vettori $\\text{item1}$, $\\text{item2}$, $\\text{item3}$, $\\text{item4}$, $\\text{item5}$, R somma elemento per elemento:\n   \n   $$\n   \\text{total\\_scores}_i = \\text{item1}_i + \\text{item2}_i + \\text{item3}_i + \\text{item4}_i + \\text{item5}_i\n   $$\n\n3. Questa tecnica consente di calcolare rapidamente i punteggi totali per tutti gli individui senza dover scrivere un ciclo esplicito, rendendo il codice più semplice e leggibile.\n\nQuesto esempio illustra come R semplifichi operazioni complesse grazie al calcolo vettorializzato, migliorando l'efficienza e la chiarezza del codice.\n:::\n\n### Attenzione al riciclo dei vettori\n\nSe i due vettori hanno lunghezze diverse, R applicherà il meccanismo di *riciclo*: gli elementi del vettore più corto verranno ripetuti ciclicamente per abbinarsi alla lunghezza del vettore più lungo. Questo comportamento, sebbene utile, richiede attenzione per evitare risultati inattesi.\n\nAd esempio:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshort_vec <- c(1, 2)\nmy_vec + short_vec\n#> [1]  4  7  8  3 10 22\n```\n:::\n\n\nIn questo caso, gli elementi di `short_vec` vengono riciclati per abbinarsi alla lunghezza di `my_vec`. Il risultato è:\n\n```\n(3+1, 5+2, 7+1, 1+2, 9+1, 20+2)\n```\n\n### Applicazione di funzioni su vettori\n\nLa vettorializzazione non si limita alle operazioni algebriche, ma si estende anche all'uso di funzioni. Supponiamo di voler calcolare il logaritmo naturale di ciascun elemento di un vettore:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlog(my_vec)\n#> [1] 1.10 1.61 1.95 0.00 2.20 3.00\n```\n:::\n\n\nLa funzione `log()` viene applicata automaticamente a ogni elemento del vettore. Analogamente, possiamo utilizzare altre funzioni predefinite di R, come:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsqrt(my_vec)  # Calcola la radice quadrata di ciascun elemento\n#> [1] 1.73 2.24 2.65 1.00 3.00 4.47\nexp(my_vec)   # Eleva e alla potenza specificata da ciascun elemento\n#> [1]        20.09       148.41      1096.63         2.72      8103.08\n#> [6] 485165195.41\n```\n:::\n\n\nIn conclusione, la vettorializzazione in R rappresenta un approccio elegante ed efficiente per gestire calcoli su vettori. Che si tratti di operazioni algebriche, operazioni tra vettori o applicazione di funzioni, la possibilità di evitare cicli espliciti migliora la leggibilità e la velocità del codice. Tuttavia, è importante prestare attenzione al riciclo dei vettori per evitare errori non intenzionali.\n\n## Gestire dati mancanti (NA)\n\nR rappresenta i dati mancanti con `NA`. La gestione dei dati mancanti dipende dalla funzione utilizzata.\n\n*Calcolo con dati mancanti*:  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntemp <- c(7.2, NA, 7.1, 6.9, 6.5, 5.8, 5.8, 5.5, NA, 5.5)\nmean(temp)  # Restituisce NA\n#> [1] NA\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(temp, na.rm = TRUE)  # Ignora i valori mancanti\n#> [1] 6.29\n```\n:::\n\n\n**Nota**: `na.rm = TRUE` è un argomento comune per ignorare i `NA`, ma non tutte le funzioni lo supportano. Consulta la documentazione della funzione per verificare come gestisce i dati mancanti.\n\nIn conclusione, manipolare vettori è un’abilità essenziale in R. Dalla selezione e modifica degli elementi all’ordinamento e gestione di dati mancanti, queste tecniche sono alla base dell’analisi dei dati in R.\n\n## I dati in R \n\nIn R, i dati possono essere rappresentati in diversi tipi e strutture. Comprendere come gestirli è fondamentale per manipolare, analizzare e riassumere i dataset più complessi.\n\n### Tipi di dati in R\n\nR supporta diversi tipi di dati:\n\n1. *Numeric*: Numeri decimali (es. `2.5`).\n2. *Integer*: Numeri interi (es. `3`).\n3. *Logical*: Valori booleani (`TRUE` o `FALSE`) e `NA` per dati mancanti.\n4. *Character*: Stringhe di testo (es. `\"hello\"`).\n5. *Factor*: Variabili categoriche (es. livelli come `\"low\"`, `\"medium\"`, `\"high\"`).\n\nPuoi verificare il tipo di un oggetto con `class()` e controllare se appartiene a un tipo specifico con funzioni come `is.numeric()`. È anche possibile convertire un tipo in un altro con funzioni come `as.character()`.\n\n### Strutture di dati in R\n\n*Vettori*: Contengono dati dello stesso tipo (es. numeri, stringhe o logici).  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_vec <- c(1, 2, 3)\nmy_vec\n#> [1] 1 2 3\n```\n:::\n\n\n*Matrici e array*: Strutture bidimensionali (matrici) o multidimensionali (array) con dati dello stesso tipo.  \n\nCreare una matrice:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_mat <- matrix(1:12, nrow = 3, byrow = TRUE)\nmy_mat\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    2    3    4\n#> [2,]    5    6    7    8\n#> [3,]    9   10   11   12\n```\n:::\n\n   \nOperazioni utili:\n   \n- *Trasposizione*: `t(my_mat)`\n- *Diagonale*: `diag(my_mat)`\n- *Moltiplicazione matriciale*: `mat1 %*% mat2`\n\n*Liste*: Possono contenere elementi di tipi diversi, inclusi vettori, matrici o altre liste.  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_list <- list(\n  numbers = c(1, 2), \n  text = \"hello\", \n  mat = matrix(1:4, nrow = 2)\n)\nmy_list$numbers  # Accedi agli elementi con il nome\n#> [1] 1 2\n```\n:::\n\n\n*Data frame*: Strutture bidimensionali che possono contenere colonne di tipi diversi. Ideale per dataset strutturati.  \n\nCreare un data frame:\n   \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nheight <- c(180, 155, 160)\nweight <- c(65, 50, 52)\nnames <- c(\"Joanna\", \"Charlotte\", \"Helen\")\n\ndataf <- data.frame(height = height, weight = weight, names = names)\nstr(dataf)  # Mostra la struttura del data frame\n#> 'data.frame':\t3 obs. of  3 variables:\n#>  $ height: num  180 155 160\n#>  $ weight: num  65 50 52\n#>  $ names : chr  \"Joanna\" \"Charlotte\" \"Helen\"\n```\n:::\n\n\nPer convertire le stringhe in fattori durante la creazione:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndataf <- data.frame(\n  height = height, \n  weight = weight, \n  names = names, \n  stringsAsFactors = TRUE\n)\n\ndataf\n#>   height weight     names\n#> 1    180     65    Joanna\n#> 2    155     50 Charlotte\n#> 3    160     52     Helen\n```\n:::\n\n\n### Operazioni utili sui data frame\n\n- *Verificare dimensioni*: `dim(dataf)`\n- *Visualizzare struttura*: `str(dataf)`\n- *Accedere a colonne*: `dataf$height`\n\n## Operazioni di base in R\n\n### Operazioni aritmetiche  \n\nCome abbiamo visto in precedenza, R supporta le classiche operazioni aritmetiche come somma (`+`), sottrazione (`-`), moltiplicazione (`*`), divisione (`/`) ed esponenziazione (`^`).\n\n### Operazioni logiche  \n\nLe operazioni logiche in R includono:  \n\n- `&`: \"and\" logico  \n- `|`: \"or\" logico  \n- `!`: \"not\" logico  \n- `>`: maggiore di  \n- `<`: minore di  \n- `==`: uguale a  \n- `!=`: diverso da  \n\nPer esempio:  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Maggiore di\n3 > 2\n#> [1] TRUE\n# Uguale a\n3 == 2\n#> [1] FALSE\n```\n:::\n\n\n::: {#exm-}\nConsideriamo l'esempio precedente, in cui abbiamo calcolato i punteggi totali dei 10 individui sulla Satisfaction With Life Scale (SWLS). Ora vogliamo determinare la proporzione di individui nel campione che ha ottenuto un punteggio totale maggiore di 15.\n\nI punteggi totali dei 10 individui sono memorizzati nella colonna `PunteggioTotale` del data frame `risultati_swls`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrisultati_swls$PunteggioTotale\n#>  [1] 16 16 23 25 11  7 20 25 15 27\n```\n:::\n\n\nPossiamo creare un vettore logico che indica, per ciascun individuo, se il suo punteggio totale supera 15. In R, l'operatore di confronto `>` restituisce un valore TRUE se la condizione è soddisfatta e FALSE altrimenti:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrisultati_swls$PunteggioTotale > 15\n#>  [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE\n```\n:::\n\n\nIn R, i valori TRUE e FALSE possono essere trattati come numeri: TRUE equivale a 1 e FALSE equivale a 0. Questo ci permette di sommare i valori logici per contare quante volte la condizione è soddisfatta. Per calcolare la proporzione, dividiamo questa somma per il numero totale di individui:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsum(risultati_swls$PunteggioTotale > 15) / length(risultati_swls$PunteggioTotale)\n#> [1] 0.7\n```\n:::\n\n\nLa proporzione è calcolata come:\n\n$$\n\\text{Proporzione} = \\frac{\\sum_{i=1}^{n} I(\\text{PunteggioTotale}_i > 15)}{n} ,\n$$\n\ndove:\n\n- $n$ è il numero totale di individui (in questo caso, 10),\n- $I(\\text{PunteggioTotale}_i > 15)$ è una funzione indicatrice che vale 1 se il punteggio dell'individuo $i$ è maggiore di 15, e 0 altrimenti.\n\nNel nostro esempio, la proporzione degli individui con punteggio totale maggiore di 15 è 0.7, cioè il 70% del campione soddisfa questa condizione.\n:::\n\n## Estrazione di sottoinsiemi di oggetti in R\n\nIn R esistono tre operatori principali per estrarre sottoinsiemi di oggetti:\n\n1. **Operatore `[ ]`**  \n   Questo operatore restituisce sempre un oggetto della stessa classe dell'originale. È utile per selezionare più elementi da un oggetto. È importante chiudere l'estrazione con `]`.  \n   \n2. **Operatore `[[ ]]`**  \n   Questo operatore viene utilizzato per estrarre elementi da liste o data frame. A differenza di `[ ]`, permette di estrarre un solo elemento alla volta e la classe dell'oggetto restituito non sarà necessariamente una lista o un data frame. L'estrazione va chiusa con `]]`.  \n   \n3. **Operatore `$`**  \n   Come visto in precedenza, questo operatore serve per estrarre elementi da una lista o un data frame utilizzando il loro nome letterale. Il comportamento semantico è simile a quello di `[[ ]]`.\n\n\n### Gli indici di un data frame in R\n\nIn R, gli indici di un *data frame* sono utilizzati per selezionare righe e colonne. La sintassi generale è:\n\n```r\ndf[i, j]\n```\n\ndove:  \n\n- `i` rappresenta l'indice o gli indici delle righe,  \n- `j` rappresenta l'indice o gli indici delle colonne.  \n\nSe uno degli indici viene omesso, si considerano *tutte le righe* o *tutte le colonne*, a seconda della dimensione omessa.\n\n\n#### Esempi pratici\n\n1. *Selezione di righe specifiche su tutte le colonne*  \n   Se vogliamo estrarre solo alcune righe, possiamo specificare gli indici delle righe nel primo argomento e lasciare vuoto il secondo. Ad esempio:\n\n   ```r\n   df[c(2, 3, 5), ]\n   ```\n\n   Questo seleziona la *seconda*, *terza* e *quinta* riga del data frame `df`, includendo *tutte le colonne*.\n\n2. *Selezione di colonne specifiche su tutte le righe*  \n   Per selezionare solo alcune colonne, specifichiamo i loro indici nel secondo argomento e lasciamo vuoto il primo. Ad esempio:\n\n   ```r\n   df[, c(2, 3, 5)]\n   ```\n\n   Questo seleziona la *seconda*, *terza* e *quinta* colonna del data frame `df`, includendo *tutte le righe*.\n\n3. *Selezione di righe e colonne specifiche*  \n   Possiamo combinare gli indici per selezionare una sotto-matrice specifica. Ad esempio:\n\n   ```r\n   df[c(2, 4), c(1, 3)]\n   ```\n\n   Questo seleziona le righe *2* e *4* e le colonne *1* e *3*.\n\n#### Ulteriori dettagli\n\n- *Selezione singola di riga o colonna*  \n   Se vogliamo estrarre una singola riga o colonna, possiamo specificare un solo valore per `i` o `j`. Ad esempio:  \n   \n   ```r\n   df[1, ]  # Prima riga, tutte le colonne\n   df[, 2]  # Seconda colonna, tutte le righe\n   ```\n\n- *Uso di nomi invece di indici*  \n   Se il data frame ha *nomi* per righe o colonne, possiamo utilizzarli per la selezione. Ad esempio:  \n   \n   ```r\n   df[\"nome_riga\", ]        # Seleziona la riga con nome \"nome_riga\"\n   df[, \"nome_colonna\"]     # Seleziona la colonna con nome \"nome_colonna\"\n   ```\n\n- *Selezione logica*  \n   Possiamo utilizzare un vettore logico per selezionare righe o colonne. Ad esempio, per selezionare le righe dove il valore nella prima colonna è maggiore di 10:  \n   \n   ```r\n   df[df[, 1] > 10, ]\n   ```\n\n\n#### Sintesi visiva\n\n| Sintassi                 | Descrizione                                       |\n|--------------------------|---------------------------------------------------|\n| `df[i, ]`                | Seleziona la riga `i` con tutte le colonne.       |\n| `df[, j]`                | Seleziona la colonna `j` con tutte le righe.      |\n| `df[c(i1, i2), c(j1, j2)]` | Seleziona righe e colonne specifiche.           |\n| `df[i, j]`               | Seleziona l'intersezione di righe e colonne.     |\n| `df[ , ]`                | Restituisce l'intero data frame.                 |\n\nQuesta flessibilità rende l'indicizzazione dei data frame in R potente ed efficace per manipolare e analizzare i dati.\n\n::: {#exm-}\nConsideriamo il data frame `iris` incluso di default in `base` R. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\niris |> head()\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n#> 4          4.6         3.1          1.5         0.2  setosa\n#> 5          5.0         3.6          1.4         0.2  setosa\n#> 6          5.4         3.9          1.7         0.4  setosa\n```\n:::\n\n\nUsiamo la funzione `head()` per stampare le prime 6 righe del data frame.\n\nL'istruzione seguente restituisce le prime tre colonne del dataset `iris`. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\niris[, 1:3] |> head()\n#>   Sepal.Length Sepal.Width Petal.Length\n#> 1          5.1         3.5          1.4\n#> 2          4.9         3.0          1.4\n#> 3          4.7         3.2          1.3\n#> 4          4.6         3.1          1.5\n#> 5          5.0         3.6          1.4\n#> 6          5.4         3.9          1.7\n```\n:::\n\n\nSelezione di colonne specifiche per nome:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\niris[, c('Sepal.Length', 'Petal.Length')] |> \n  head()  \n#>   Sepal.Length Petal.Length\n#> 1          5.1          1.4\n#> 2          4.9          1.4\n#> 3          4.7          1.3\n#> 4          4.6          1.5\n#> 5          5.0          1.4\n#> 6          5.4          1.7\n```\n:::\n\n\nSelezione di una singola colonna:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\niris[, 'Petal.Length'] \n#>   [1] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 1.5 1.6 1.4 1.1 1.2 1.5 1.3 1.4\n#>  [19] 1.7 1.5 1.7 1.5 1.0 1.7 1.9 1.6 1.6 1.5 1.4 1.6 1.6 1.5 1.5 1.4 1.5 1.2\n#>  [37] 1.3 1.4 1.3 1.5 1.3 1.3 1.3 1.6 1.9 1.4 1.6 1.4 1.5 1.4 4.7 4.5 4.9 4.0\n#>  [55] 4.6 4.5 4.7 3.3 4.6 3.9 3.5 4.2 4.0 4.7 3.6 4.4 4.5 4.1 4.5 3.9 4.8 4.0\n#>  [73] 4.9 4.7 4.3 4.4 4.8 5.0 4.5 3.5 3.8 3.7 3.9 5.1 4.5 4.5 4.7 4.4 4.1 4.0\n#>  [91] 4.4 4.6 4.0 3.3 4.2 4.2 4.2 4.3 3.0 4.1 6.0 5.1 5.9 5.6 5.8 6.6 4.5 6.3\n#> [109] 5.8 6.1 5.1 5.3 5.5 5.0 5.1 5.3 5.5 6.7 6.9 5.0 5.7 4.9 6.7 4.9 5.7 6.0\n#> [127] 4.8 4.9 5.6 5.8 6.1 6.4 5.6 5.1 5.6 6.1 5.6 5.5 4.8 5.4 5.6 5.1 5.1 5.9\n#> [145] 5.7 5.2 5.0 5.2 5.4 5.1\n```\n:::\n\n\noppure\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\niris$Petal.Length\n#>   [1] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 1.5 1.6 1.4 1.1 1.2 1.5 1.3 1.4\n#>  [19] 1.7 1.5 1.7 1.5 1.0 1.7 1.9 1.6 1.6 1.5 1.4 1.6 1.6 1.5 1.5 1.4 1.5 1.2\n#>  [37] 1.3 1.4 1.3 1.5 1.3 1.3 1.3 1.6 1.9 1.4 1.6 1.4 1.5 1.4 4.7 4.5 4.9 4.0\n#>  [55] 4.6 4.5 4.7 3.3 4.6 3.9 3.5 4.2 4.0 4.7 3.6 4.4 4.5 4.1 4.5 3.9 4.8 4.0\n#>  [73] 4.9 4.7 4.3 4.4 4.8 5.0 4.5 3.5 3.8 3.7 3.9 5.1 4.5 4.5 4.7 4.4 4.1 4.0\n#>  [91] 4.4 4.6 4.0 3.3 4.2 4.2 4.2 4.3 3.0 4.1 6.0 5.1 5.9 5.6 5.8 6.6 4.5 6.3\n#> [109] 5.8 6.1 5.1 5.3 5.5 5.0 5.1 5.3 5.5 6.7 6.9 5.0 5.7 4.9 6.7 4.9 5.7 6.0\n#> [127] 4.8 4.9 5.6 5.8 6.1 6.4 5.6 5.1 5.6 6.1 5.6 5.5 4.8 5.4 5.6 5.1 5.1 5.9\n#> [145] 5.7 5.2 5.0 5.2 5.4 5.1\n```\n:::\n\n\nPer selezionare righe specifiche, definiamo gli indici corrispondenti. Per esempio, l'istruzione seguente restituisce le righe 1 e 3.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\niris[c(1, 3), ]\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n```\n:::\n\n\nFiltraggio logico di righe:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\niris[iris$Species == 'versicolor', ] |> head()\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n#> 51          7.0         3.2          4.7         1.4 versicolor\n#> 52          6.4         3.2          4.5         1.5 versicolor\n#> 53          6.9         3.1          4.9         1.5 versicolor\n#> 54          5.5         2.3          4.0         1.3 versicolor\n#> 55          6.5         2.8          4.6         1.5 versicolor\n#> 56          5.7         2.8          4.5         1.3 versicolor\n```\n:::\n\n\nRestituisce le righe con `Species` uguale a \"versicolor\". Numero di righe e colonne del sottoinsieme:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndim(iris[iris$Species == 'versicolor', ])\n#> [1] 50  5\n```\n:::\n\n\n:::\n\n### Filtraggio avanzato con operatori logici\n\nGli operatori logici `&` (AND), `|` (OR) e `!` (NOT) permettono un filtraggio più sofisticato.\n\nEsempio: Filtrare le osservazioni di specie \"versicolor\" con lunghezza del sepalo non superiore a 5.0:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\niris[(iris$Species == 'versicolor') & (iris$Sepal.Length <= 5.0), ]\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n#> 58          4.9         2.4          3.3           1 versicolor\n#> 61          5.0         2.0          3.5           1 versicolor\n#> 94          5.0         2.3          3.3           1 versicolor\n```\n:::\n\n\nNumero di osservazioni trovate:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndim(iris[(iris$Species == 'versicolor') & (iris$Sepal.Length <= 5.0), ])\n#> [1] 3 5\n```\n:::\n\n\n## Riflessioni conclusive {.unnumbered .unlisted}\n\nR non è soltanto un linguaggio di programmazione per la statistica, ma rappresenta una filosofia che si fonda su tre principi chiave: *apertura*, *collaborazione* e *avanzamento della conoscenza scientifica*. \n\nPer chi si avvicina a R, sia nel campo della comunicazione sia in altri ambiti, cogliere questa filosofia è essenziale per apprezzarne appieno il valore. R promuove non solo competenze tecniche, ma anche un impegno verso pratiche di *ricerca trasparente e riproducibile*, che costituiscono un pilastro fondamentale per una scienza rigorosa e affidabile.\n\n**Open Source**  \nR è un software open source, liberamente accessibile a tutti. Questo significa che chiunque può visualizzarne, modificarne e distribuirne il codice sorgente, promuovendo un ambiente trasparente e collaborativo. Essendo gratuito, R garantisce accessibilità a ricercatori di tutto il mondo, indipendentemente dal budget o dal supporto istituzionale. Inoltre, grazie alla sua natura aperta, R beneficia del contributo collettivo di una comunità globale eterogenea.\n\n**Contributi della Comunità**  \nLa comunità di R è uno dei suoi punti di forza principali. Statistici, ricercatori e data scientist di diverse discipline arricchiscono continuamente R sviluppando pacchetti: raccolte di funzioni, dati e codice che ampliano le sue funzionalità. Questa collaborazione ha portato alla creazione di migliaia di pacchetti che coprono tecniche statistiche, metodi grafici e strumenti per la manipolazione dei dati, rendendo R uno strumento sempre più versatile e adatto a un’ampia gamma di esigenze di ricerca.\n\n**Ricerca Riproducibile**  \nLa ricerca riproducibile consiste nel condurre studi in modo tale che altri possano replicarne i risultati utilizzando gli stessi dati e seguendo la stessa metodologia. Questo approccio è cruciale per la validazione delle scoperte scientifiche, permettendo la verifica dei risultati e la costruzione di nuove conoscenze su basi solide.\n\nR facilita la ricerca riproducibile grazie a:  \n\n- Un ecosistema completo di pacchetti per l'analisi dei dati e la generazione di report dinamici.  \n- Strumenti come R Markdown e Quarto, che permettono di integrare testo descrittivo e codice R in un unico documento. Questa integrazione consente di documentare ogni fase del processo di ricerca—dalla pulizia dei dati all’analisi e alla presentazione dei risultati—garantendo trasparenza e replicabilità.  \n\nIn conclusione, comprendere la filosofia open source di R e il suo ruolo nella promozione della ricerca riproducibile fornisce un quadro chiaro del motivo per cui R è diventato uno strumento essenziale per ricercatori e statistici di diverse discipline. Per chi opera in psicologia, sfruttare le potenzialità di R significa produrre risultati di ricerca più trasparenti, replicabili e credibili, contribuendo alla robustezza e affidabilità della conoscenza scientifica nel settore.\n\n\n::: {.callout-important title=\"Problemi 1\" collapse=\"true\"}\nSvolgere gli esercizi da 1 a 38, sia in modo **manuale** che utilizzando **R**. Gli esercizi sono disponibili al seguente link:  \n[Esercizi su Summation Notation](https://math.libretexts.org/Courses/Cosumnes_River_College/Math_370%3A_Precalculus/07%3A_Sequences_and_the_Binomial_Theorem/7.02%3A_Summation_Notation/7.2E%3A_Exercises).\n:::\n\n::: {.callout-important title=\"Problemi 2\" collapse=\"true\"}\nIn questo esercizio, lavorerai con i dati della **Satisfaction With Life Scale (SWLS)** raccolti da ciascuno degli studenti del gruppo TPV di appartenenza. \n\n*Istruzioni SWLS:* Di seguito sono riportate alcune affermazioni con cui puoi descrivere la tua soddisfazione rispetto alla tua vita. Indica quanto sei d'accordo con ciascuna affermazione utilizzando la scala di risposta fornita.\n\n- Il più delle volte la mia vita è vicina al mio ideale di vita.\n- Le condizioni della mia vita sono eccellenti.\n- Sono soddisfatto/a della mia vita.\n- Finora ho ottenuto le cose importanti che voglio dalla vita.\n- Se io potessi rivivere la mia vita, non cambierei quasi nulla.\n\nLa SWLS utilizza una scala Likert a 7 punti, con i seguenti ancoraggi:\n\n1. Fortemente in disaccordo\n2. Disaccordo\n3. Leggermente in disaccordo\n4. Né d'accordo né in disaccordo\n5. Leggermente d'accordo\n6. D'accordo\n7. Fortemente d'accordo\n\nIl tuo compito sarà analizzare i dati raccolti **sia manualmente su carta** che utilizzando **R**.\n\n**Parte 1: Calcolo Manuale**\n\n1. **Calcolo del punteggio totale**  \n\n   - La SWLS è composta da 5 item, ciascuno valutato su una scala Likert da 1 a 7.\n   - Somma i punteggi dei 5 item per ciascun partecipante per ottenere il punteggio totale.  \n   - Registra i punteggi totali su carta.\n\n2. **Determinazione della media del campione**  \n\n   - Calcola la media aritmetica dei punteggi totali dei 10 studenti.\n   - Scrivi il calcolo e il risultato.\n\n3. **Calcolo della deviazione standard**  \n\n   - Calcola la deviazione standard dei punteggi totali manualmente utilizzando la formula:\n\n     $$\n     s^2 = \\sqrt{\\frac{\\sum_{i=1}^n (x_i - \\bar{x})^2}{n-1}}.\n     $$\n\n   - Registra il risultato.\n\n**Parte 2: Analisi con R**\n\n4. **Creazione del dataset in R**  \n\n   - Inserisci i dati in R come un vettore chiamato `swls_scores`.\n\n5. **Calcolo della media e della deviazione standard in R**  \n\n   - Usa le funzioni `mean()` e `sd()` per ottenere la media e la deviazione standard dei punteggi totali.\n\n6. **Visualizzazione dei dati**  \n\n   - Crea un istogramma per visualizzare la distribuzione dei punteggi totali utilizzando `hist()`. Se non conosci l'istogramma, fai una ricerca su web; commenta il risultato ottenuto.\n\n7. **Identificazione dei punteggi superiori a 20**  \n\n   - Utilizza un'operazione logica per contare quanti partecipanti hanno un punteggio totale maggiore di 20.\n\n8. **Filtraggio dei dati**  \n\n   - Estrai e visualizza solo i punteggi superiori alla media del campione.\n\n9. **Esportazione dei risultati**  \n\n   - Salva i punteggi totali in un file CSV utilizzando la funzione `write.csv()`.\n\n**Consegna**\n\n- Scrivi le risposte della **Parte 1** su carta.\n- Scrivi il codice e i risultati della **Parte 2** in un file `.R` e invialo come consegna.\n:::\n\n::: {.callout-tip title=\"Soluzioni 2\" collapse=\"true\"}\n**Parte 1: Calcolo Manuale**\n\n1. **Calcolo del punteggio totale**\n   - Supponiamo che i punteggi per 10 studenti siano:\n\n     | Studente | Item 1 | Item 2 | Item 3 | Item 4 | Item 5 | Totale |\n     |----------|--------|--------|--------|--------|--------|--------|\n     | 1        | 5      | 4      | 6      | 3      | 2      | 20     |\n     | 2        | 4      | 2      | 5      | 3      | 2      | 16     |\n     | 3        | 6      | 4      | 6      | 4      | 3      | 23     |\n     | 4        | 7      | 6      | 5      | 3      | 4      | 25     |\n     | 5        | 3      | 2      | 3      | 2      | 1      | 11     |\n     | 6        | 2      | 1      | 2      | 1      | 1      | 7      |\n     | 7        | 5      | 4      | 5      | 3      | 3      | 20     |\n     | 8        | 6      | 5      | 7      | 4      | 3      | 25     |\n     | 9        | 4      | 3      | 4      | 2      | 2      | 15     |\n     | 10       | 7      | 6      | 5      | 5      | 4      | 27     |\n\n2. **Determinazione della media**  \n   - Media:  \n\n     $$\n     \\bar{x} = \\frac{20+16+23+25+11+7+20+25+15+27}{10} = 18.9\n     $$\n\n3. **Calcolo della deviazione standard**  \n   - La deviazione standard è:\n\n     $$\n     s = \\sqrt{\\frac{1}{9} \\sum (x_i - 18.9)^2} \\approx 6.56\n     $$\n\n**Parte 2: Analisi con R**\n\n4. **Creazione del dataset in R**\n   ```r\n   swls_scores <- c(20, 16, 23, 25, 11, 7, 20, 25, 15, 27)\n   ```\n\n5. **Calcolo della media e della deviazione standard**\n   ```r\n   mean(swls_scores)  # Media\n   sd(swls_scores)    # Deviazione standard\n   ```\n\n6. **Visualizzazione dei dati**\n   ```r\n   hist(swls_scores, main=\"Distribuzione SWLS\", xlab=\"Punteggi\", col=\"lightblue\", border=\"black\")\n   ```\n\n7. **Identificazione dei punteggi superiori a 20**\n   ```r\n   sum(swls_scores > 20)  # Numero di studenti con punteggio > 20\n   ```\n\n8. **Filtraggio dei dati**\n   ```r\n   swls_scores[swls_scores > mean(swls_scores)]\n   ```\n\n9. **Esportazione dei risultati**\n   ```r\n   write.csv(data.frame(Student=1:10, Score=swls_scores), \"swls_results.csv\", row.names=FALSE)\n   ```\n\n**Conclusione**\nQuesti esercizi hanno permesso di confrontare il calcolo manuale con l'automatizzazione tramite R, facilitando l'analisi statistica della SWLS.\n:::\n\n::: {.callout-note collapse=true title=\"Informazioni sull'ambiente di sviluppo\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.5.1 (2025-06-13)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.6.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1\n#> \n#> locale:\n#> [1] C/UTF-8/C/C/C/C\n#> \n#> time zone: Europe/Rome\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#>  [1] pillar_1.11.0         tinytable_0.13.0      patchwork_1.3.2      \n#>  [4] ggdist_3.3.3          tidybayes_3.0.7       bayesplot_1.14.0     \n#>  [7] ggplot2_3.5.2         reliabilitydiag_0.2.1 priorsense_1.1.1     \n#> [10] posterior_1.6.1       loo_2.8.0             rstan_2.32.7         \n#> [13] StanHeaders_2.32.10   brms_2.22.0           Rcpp_1.1.0           \n#> [16] sessioninfo_1.2.3     conflicted_1.2.0      janitor_2.2.1        \n#> [19] matrixStats_1.5.0     modelr_0.1.11         tibble_3.3.0         \n#> [22] dplyr_1.1.4           tidyr_1.3.1           rio_1.2.3            \n#> [25] here_1.0.1           \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] svUnit_1.0.8          tidyselect_1.2.1      farver_2.1.2         \n#>  [4] fastmap_1.2.0         TH.data_1.1-4         tensorA_0.36.2.1     \n#>  [7] pacman_0.5.1          digest_0.6.37         timechange_0.3.0     \n#> [10] estimability_1.5.1    lifecycle_1.0.4       survival_3.8-3       \n#> [13] magrittr_2.0.3        compiler_4.5.1        rlang_1.1.6          \n#> [16] tools_4.5.1           knitr_1.50            bridgesampling_1.1-2 \n#> [19] htmlwidgets_1.6.4     curl_7.0.0            pkgbuild_1.4.8       \n#> [22] RColorBrewer_1.1-3    abind_1.4-8           multcomp_1.4-28      \n#> [25] withr_3.0.2           purrr_1.1.0           grid_4.5.1           \n#> [28] stats4_4.5.1          colorspace_2.1-1      xtable_1.8-4         \n#> [31] inline_0.3.21         emmeans_1.11.2-8      scales_1.4.0         \n#> [34] MASS_7.3-65           cli_3.6.5             mvtnorm_1.3-3        \n#> [37] rmarkdown_2.29        ragg_1.5.0            generics_0.1.4       \n#> [40] RcppParallel_5.1.11-1 cachem_1.1.0          stringr_1.5.1        \n#> [43] splines_4.5.1         parallel_4.5.1        vctrs_0.6.5          \n#> [46] V8_7.0.0              Matrix_1.7-4          sandwich_3.1-1       \n#> [49] jsonlite_2.0.0        arrayhelpers_1.1-0    systemfonts_1.2.3    \n#> [52] glue_1.8.0            codetools_0.2-20      distributional_0.5.0 \n#> [55] lubridate_1.9.4       stringi_1.8.7         gtable_0.3.6         \n#> [58] QuickJSR_1.8.0        htmltools_0.5.8.1     Brobdingnag_1.2-9    \n#> [61] R6_2.6.1              textshaping_1.0.3     rprojroot_2.1.1      \n#> [64] evaluate_1.0.5        lattice_0.22-7        backports_1.5.0      \n#> [67] memoise_2.0.1         broom_1.0.9           snakecase_0.11.1     \n#> [70] rstantools_2.5.0      coda_0.19-4.1         gridExtra_2.3        \n#> [73] nlme_3.1-168          checkmate_2.3.3       xfun_0.53            \n#> [76] zoo_1.8-14            pkgconfig_2.0.3\n```\n:::\n\n:::\n\n## Bibliografia {.unnumbered .unlisted}",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}